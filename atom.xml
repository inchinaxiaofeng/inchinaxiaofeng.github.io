<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Marina的所思所想</title>
  <icon>https://www.gravatar.com/avatar/4c79ae7b8815420b6f7c96fec636a7bc</icon>
  <subtitle>Shall I compare thee to a summer&#39;s day?</subtitle>
  <link href="https://inchinaxiaofeng.github.io/atom.xml" rel="self"/>
  
  <link href="https://inchinaxiaofeng.github.io/"/>
  <updated>2025-01-16T09:49:31.562Z</updated>
  <id>https://inchinaxiaofeng.github.io/</id>
  
  <author>
    <name>Marina TOO</name>
    <email>inchinaxiaofeng@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ArceOS加载Linux应用的思路</title>
    <link href="https://inchinaxiaofeng.github.io/2025/01/13/ArceOS%E5%8A%A0%E8%BD%BDLinux%E5%BA%94%E7%94%A8%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
    <id>https://inchinaxiaofeng.github.io/2025/01/13/ArceOS%E5%8A%A0%E8%BD%BDLinux%E5%BA%94%E7%94%A8%E7%9A%84%E6%80%9D%E8%B7%AF/</id>
    <published>2025-01-13T11:43:44.000Z</published>
    <updated>2025-01-16T09:49:31.562Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="0-问题的出现"><a href="#0-问题的出现" class="headerlink" title="0. 问题的出现"></a>0. 问题的出现</h1><p>因为在ArceOS开发组实习中，我经手的项目是令ArceOS支持原生Linux应用，所以我对这些问题比较熟悉，在此写一篇文章来介绍这个过程。</p><h1 id="1-两大思路"><a href="#1-两大思路" class="headerlink" title="1. 两大思路"></a>1. 两大思路</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;0-问题的出现&quot;&gt;&lt;a href=&quot;#0-问题的出现&quot; class=&quot;headerlink&quot; title=&quot;0. 问题的出现&quot;&gt;&lt;/a&gt;0. 问题的出现&lt;/h1&gt;&lt;p&gt;因为在ArceOS开发组实习中，我经手的项目是令ArceOS支持原生L</summary>
      
    
    
    
    
    <category term="ArceOS开发日记" scheme="https://inchinaxiaofeng.github.io/tags/ArceOS%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
    <category term="动态加载" scheme="https://inchinaxiaofeng.github.io/tags/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
    <category term="ELF" scheme="https://inchinaxiaofeng.github.io/tags/ELF/"/>
    
    <category term="符号表" scheme="https://inchinaxiaofeng.github.io/tags/%E7%AC%A6%E5%8F%B7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux动态加载过程详解与手撕SO文件</title>
    <link href="https://inchinaxiaofeng.github.io/2025/01/12/%E6%89%8B%E6%92%95SO%E6%96%87%E4%BB%B6/"/>
    <id>https://inchinaxiaofeng.github.io/2025/01/12/%E6%89%8B%E6%92%95SO%E6%96%87%E4%BB%B6/</id>
    <published>2025-01-12T04:23:42.000Z</published>
    <updated>2025-01-13T11:44:21.670Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="0-问题的提出与笔者的目标"><a href="#0-问题的提出与笔者的目标" class="headerlink" title="0. 问题的提出与笔者的目标"></a>0. 问题的提出与笔者的目标</h1><p>石老师对于为ArceOS适配Linux ELF文件动态链接提出了两个不同思路：<br><img src="http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/49f3055a02621dea4523bb6eec597afa.jpg" alt="49f3055a02621dea4523bb6eec597afa"></p><p>在为ArceOS实现动态加载的时候，同组张明洋同学贡献了这样的思路：<br>通过访问<code>.rela.plt</code>实现链接时重定位，通过在<code>.rela.plt</code>中得到需要重定位的函数条目，然后在自行用Rust实现的兼容musl库中寻找目标函数条目，通过访问<code>r_offset</code>，搜寻对应地址的解析函数GOT的表项地址，将Rust兼容库对应函数的地址（Rust中的）填入GOT的对应表项目中。属于上图中的第一种思路。</p><p>我希望通过这篇文章的总结，能够对整个Linux的动态加载机制与SO文件的组成有足够的了解，深入分析第一种实现方式，探索第二种实现方式的可能性。</p><p>我的期望是，通过最小化修改musl库（即尽可能通过复制的方式），通过传递abi table的方式，对musl库中的关键节点进行替换，在不需要实现一个Rust版的兼容musl的C库的情况下，在加载原始Linux应用的同时，向内存中加载替换版so库，并且通过修改<code>GOT</code>的方式，以及修改<code>PLT</code>函数的方式，扩展支持到延迟加载动态库中函数的地步。</p><h1 id="1-静态链接与动态链接概念的简单区分"><a href="#1-静态链接与动态链接概念的简单区分" class="headerlink" title="1. 静态链接与动态链接概念的简单区分"></a>1. 静态链接与动态链接概念的简单区分</h1><p>静态链接是将所有第三方库函数全部打包到了一个可执行文件中，其体积较大，加载简单，其使用的库常用名称是<code>*.a</code>，是通过<code>ar</code>构建的；<br>动态链接不链接库文件，而是在运行时去加载，体积小，实现复杂，其使用的库常用名称为<code>*.so</code>，通过<code>gcc</code>类编译器构建的。</p><p>我们把编译后但是还未链接的二进制机器码文件称为目标文件（Object File），那些第三方库是其他人编译打包好的目标文件，这些库里面包含了一些函数，我们可以直接调用而不用自己动手写一遍。在编译构建自己的可执行文件时，使用静态链接的方式，其实就是将所需的静态库与目标文件打包到一起。最终的可执行文件除了有自己的程序外，还包含了这些第三方的静态库，可执行文件比较臃肿。</p><p>动态链接不将所有的第三方库都打包到最终的可执行文件上，而是只记录用到了哪些动态链接库，在运行时才将那些第三方库装载（Load）进来。装载是指将磁盘上的程序和数据加载到内存上。</p><blockquote><p>注意的是，不同操作系统的动态链接库格式不同，linux的是共享目标文件（Shared Object）<code>.so</code>，windows的是动态链接库（Dynamic Link Library）<code>.dll</code></p></blockquote><h1 id="2-位置无关码PIC的原理、动态链接库、代码重定位"><a href="#2-位置无关码PIC的原理、动态链接库、代码重定位" class="headerlink" title="2. 位置无关码PIC的原理、动态链接库、代码重定位"></a>2. 位置无关码PIC的原理、动态链接库、代码重定位</h1><p>问题：动态链接库在编译时并未确定其在内存中的具体位置，而是在运行时加载，因此必须进行加载时重定位。</p><p>NOTE!: 本节参考文章：<a href="https://blog.csdn.net/tilblackout/article/details/135585340">https://blog.csdn.net/tilblackout/article/details/135585340</a></p><h2 id="1-位置无关的编译器选项"><a href="#1-位置无关的编译器选项" class="headerlink" title="1. 位置无关的编译器选项"></a>1. 位置无关的编译器选项</h2><p>这四个编译选项与位置无关代码(Position Independent Code，PIC)和位置无关可执行文件(Position Independent Executable，PIE)有关。它们的作用主要是为了提高代码的可重定位性，使得代码更适用于共享库和在内存中的不同位置加载的情况：</p><ol><li><code>-fPIC(Position Independent Code)</code><ul><li><strong>作用：</strong>生成位置无关代码，适用于共享库。</li><li><strong>用途：</strong>当编译共享库时，通常需要使用<code>-fPIC</code>，以确保库中代码可以在内存中的不同位置加载。</li></ul></li><li><code>-fPIE(Position Independent Executable)</code><ul><li><strong>作用：</strong> 生成位置无关的可执行文件，适用于可执行文件。</li><li><strong>用途：</strong> 当编译可执行文件时，使用<code>-fPIE</code>会生成一个可以在内存中的不同位置加载的可执行文件。</li></ul></li><li><code>-pie(Position Independent Executable)</code><ul><li><strong>作用：</strong> 生成位置无关的可执行文件，与<code>-fPIE</code>类似。</li><li><strong>用途：</strong> 在链接阶段，使用<code>-pie</code>可以生成位置无关的可执行文件，这也是为了提高安全性。与 <code>-fPIE</code> 不同的是，<code>-pie</code>在链接时指定，而不是在编译时。</li></ul></li><li><code>-fno-pic</code><ul><li><strong>作用：</strong> 禁用位置无关代码。</li><li><strong>用途：</strong> 当不需要位置无关代码时，使用<code>-fno-pic</code>禁用，生成与地址相关的代码。</li></ul></li></ol><h2 id="2-加载动态链接库"><a href="#2-加载动态链接库" class="headerlink" title="2. 加载动态链接库"></a>2. 加载动态链接库</h2><h3 id="2-1-问题引入"><a href="#2-1-问题引入" class="headerlink" title="2.1. 问题引入"></a>2.1. 问题引入</h3><p>构建动态链接库的时候，链接器事先无法知道任何给定共享库将在进程的虚拟内存中的哪个位置加载。这个问题的解决方法视操作系统不同而不同，这里以Linux为例来讲解一个实现的思路。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> test = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test += a;</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码编译成动态链接库后，涉及到用<code>mov</code>指令将全局变量<code>test</code>的值从内存的位置取到寄存器中。但是<code>mov</code>指令需要<strong>绝对地址</strong>，而动态库是没有预定义的加载地址，所以这个地址将在运行时确定。</p><p>LinuxELF共享库中，主要有两个解决这个问题的方法：加载时重定位和位置无关代码。</p><h3 id="2-2-加载时重定位（Load-time-relocation）"><a href="#2-2-加载时重定位（Load-time-relocation）" class="headerlink" title="2.2. 加载时重定位（Load-time relocation）"></a>2.2. 加载时重定位（Load-time relocation）</h3><ul><li><strong>实时性：</strong> 在加载时进行地址重定位，即在将共享库加载到进程的地址空间时，需要根据实际的加载地址对库中的数据和代码引用进行修正。这就是为什么称之为“加载时”重定位。</li><li><strong>非位置无关：</strong> 共享库中的代码和数据引用是使用绝对地址的，因此必须在加载时将这些地址调整为实际的加载地址。</li></ul><p>存在的问题：</p><ol><li>性能问题<br> 当一个应用程序加载与加载时重定位条目关联的共享库时，尽管只需加载重定位的条目，但如果一个复杂的软件在启动时加载多个大型共享库，并且每个库都需要进行加载时重定位，会导致应用程序启动时间明显延迟。</li><li>代码段无法共享<br> 共享库的初衷之一是为了节省RAM，使得一些常见的共享库能够被多个应用程序共享。这意味着对于每个应用程序，共享库都必须完全加载到内存中，导致相当大量的RAM浪费。</li><li>要求代码段可写<br> 为了允许在加载时动态地修改其中的绝对地址，将其调整为实际的加载地址，加载时重定位要求代码段保持可写状态，这带来了潜在的代码安全风险。</li></ol><p>对于加载时重定位这种方法，实际上已经过时了，甚至最新的编译器已经不支持这种方法。PIC是目前常见的解决方案，接下来我们就深入讨论一下位置无关代码。</p><h2 id="3-位置无关代码（Position-Independent-Code）"><a href="#3-位置无关代码（Position-Independent-Code）" class="headerlink" title="3. 位置无关代码（Position Independent Code）"></a>3. 位置无关代码（Position Independent Code）</h2><p>PIC的原理很简单：在代码中对所有全局数据和函数引用添加一个额外的中间层。通过巧妙地利用链接和加载过程中的结果，使共享库的代码部分实现位置无关。</p><h3 id="3-1-代码段和数据段之间的偏移"><a href="#3-1-代码段和数据段之间的偏移" class="headerlink" title="3.1.  代码段和数据段之间的偏移"></a>3.1.  代码段和数据段之间的偏移</h3><p>PIC的一个关键点是利用链接时已知的代码段和数据段之间的偏移。当链接器合并多个目标文件时，它会整合它们的各个部分，形成一个大的代码段。因此，链接器了解各个部分的大小和它们的相对位置。</p><p>举例来说，代码段可能直接跟在数据部分后面，这意味着从代码部分中的任意指令到数据段开头的偏移量等于代码部分的大小减去指令距离代码部分开头的偏移量。这两个量都是链接器已知的。</p><p>当然，其实在代码段和数据段之间有别的段，或者两个段的位置关系不是如此，都不影响链接器<strong>知晓</strong>它们的位置，并了解到所有段的大小。</p><h3 id="3-2-全局偏移表（Global-Offset-Table）"><a href="#3-2-全局偏移表（Global-Offset-Table）" class="headerlink" title="3.2. 全局偏移表（Global Offset Table）"></a>3.2. 全局偏移表（Global Offset Table）</h3><p>全局偏移表<code>GOT</code>可以帮我们实现位置无关数据寻址。实际上<code>GOT</code>就是一个地址表，存储在数据段中。假设代码段中的某个指令想要引用一个变量。<strong>它会引用<code>GOT</code>中的一个条目，而不是直接使用绝对地址引用(这将需要进行重定位)。</strong>由于<code>GOT</code>位于数据段的一个已知位置，这个引用是<strong>相对的</strong>，并且在链接器中是<strong>已知的</strong>，而<code>GOT</code>条目本身将包含变量的<strong>绝对地址</strong>。</p><p>通过将变量引用重定向到GOT，我们避免了在代码段中直接使用绝对地址，而是通过GOT中的条目进行引用，从而减少了需要在加载时进行的具体地址修正。但是，我们在数据段中引入了一个新的重定位，因为全局偏移表仍然需要包含变量的绝对地址。那么，这样做的优点有哪些呢？</p><ul><li>加载时重定位需要对每个变量的引用都进行重定位，而在全局偏移表中，只需要对每个变量进行一次重定位</li><li>数据段是可写的，并且在进程之间不共享</li></ul><p>实际上这就是解决前面提到的加载时重定位的三个缺点。</p><p> ==这里我们需要重点关注的是==：<strong>Linux的动态链接器如何在运行时对全局偏移表进行修改</strong>。我们将通过了解这个内容，获得在ArceOS中直接加载SO文件的必要知识。</p><h3 id="3-3-函数的重定位"><a href="#3-3-函数的重定位" class="headerlink" title="3.3. 函数的重定位"></a>3.3. 函数的重定位</h3><p>前面介绍的是全局变量的重定位，对于函数也需要重定位，它有着另一种机制：懒绑定。</p><p>当共享库引用某个函数时，函数的真实地址在加载时未知。为了加速这个过程，引入了过程链接表(PLT)。PLT包含对函数进行间接调用的代码，而不是直接包含函数地址。在程序执行时，当函数首次调用时，PLT代码负责将函数的真实地址填充到全局偏移表(GOT)中的相应条目。此后的调用直接通过GOT访问函数地址，避免了每个函数调用时的绑定延迟。这种机制减少了不必要的解析工作，提高了程序执行效率。</p><p>==这里我们可以知道==：存在某种方式，能够让我们在ArceOS中进行函数重定位。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>至此解释了什么是位置无关代码，以及它如何帮助创建具有可共享只读文本段的共享库。位置无关代码(PIC)通过引入全局偏移表(GOT)和过程链接表(PLT)实现，解决了共享库加载时的重定位问题。GOT提供了数据和函数的间接引用，PLT实现了懒绑定，推迟函数地址的解析。当然这也伴随额外的内存加载和寄存器使用成本，但在权衡之下，现代的编译器都更倾向于使用PIC。</p><h1 id="3-位置无关代码的核心：GOT和PLT解析"><a href="#3-位置无关代码的核心：GOT和PLT解析" class="headerlink" title="3. 位置无关代码的核心：GOT和PLT解析"></a>3. 位置无关代码的核心：<code>GOT</code>和<code>PLT</code>解析</h1><h2 id="3-1-GOT和PLT是什么？"><a href="#3-1-GOT和PLT是什么？" class="headerlink" title="3.1. GOT和PLT是什么？"></a>3.1. <code>GOT</code>和<code>PLT</code>是什么？</h2><ul><li>  <code>PLT</code>: Procedure Link Table，程序链接表</li><li>  <code>GOT</code>: Global Offset Table，全局偏移表</li></ul><p>通过将这两个表互相配合解决外部函数符号地址，解决运行时重定位的问题。这种方法可以让函数在调用时才确定地址，进程的启动时间加快，只需要一次绑定，又叫延迟绑定。</p><p>如果调用者使用了共享库的符号，则调用者的数据段会有一个GOT，用于记录共享库符号的地址；如果共享库A作为调用者使用了共享库B的符号，则共享库A的数据段也会有一个GOT。由于编译的时候不能知道共享库的符号地址，所以调用者通过GOT获取共享库的符号地址，运行时链接只需要修改位于数据段的GOT的内容，不需要对调用者的代码段重定位。</p><p>共享库有数据段和代码段，数据段是每个应用程序各自有一份，代码段是每个应用程序共享一份。</p><h2 id="3-2-示例引入与具体分析"><a href="#3-2-示例引入与具体分析" class="headerlink" title="3.2. 示例引入与具体分析"></a>3.2. 示例引入与具体分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_banner</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;...\n&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;begin\n&quot;</span>);</span><br><span class="line">  print_banner();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码使用了一个外部的函数printf，这个函数会在一个共享库中存在。经过编译和链接之后，上述代码可执行文件中的<code>print_banner</code>函数的汇编指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0000000000001149 &lt;print_banner&gt;:</span><br><span class="line">    1149:f3 0f 1e fa          endbr64 </span><br><span class="line">    114d:55                   push   %rbp</span><br><span class="line">    114e:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">    1151:48 8d 05 ac 0e 00 00 lea    0xeac(%rip),%rax        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line">    1158:48 89 c7             mov    %rax,%rdi</span><br><span class="line">    115b:e8 f0 fe ff ff       call   1050 &lt;puts@plt&gt;# **&lt;puts函数的地址&gt;**</span><br><span class="line">    1160:90                   nop</span><br><span class="line">    1161:5d                   pop    %rbp</span><br><span class="line">    1162:c3                   ret     </span><br></pre></td></tr></table></figure><p>可以看到，<code>print_banner</code>调用了<code>puts</code>函数（函数内部比较简单，直接被优化成puts了），而<code>puts</code>函数位于<code>glibc</code>动态库内，所以在编译和链接阶段，链接器无法知道进程运行起来后<code>puts</code>函数加载的地址。所以，上述的**&lt;puts函数的地址&gt;**一项是无法填充的，只有进程运行起来，<code>puts</code>函数的地址才能确定。</p><p>问题来了：<strong>进程运行起来之后，glibc动态库也装载了，puts函数地址亦已确定，上述call指令如何修改（重定位）呢？</strong></p><p><em>2.2.节中提到的“加载时重定位”就是通过将</em>*&lt;puts函数的地址&gt;*<em>修改为<code>puts</code>函数的真正地址解决的</em>。如前所说：</p><ul><li>当进程启动，<code>libc.so</code>装载完毕，那么<code>puts</code>对应二进制代码所在<code>.text</code>的地址也确定了，就是说<code>puts</code>函数的地址是明确的，修改<code>call puts</code>对应汇编二进制代码，改为<code>puts</code>正确的地址即可。但现代操作系统在不做特殊操作情况下，是不允许我们修改代码段的（实际还是可以修改的）。<br>  ==不过，既然我们自己在写ArceOS，其实完全可以这么做。==张明阳同学的代码就是直接将对应的函数加载到跳转的地址（原本是@plt的）。<br>  更好的，我们可以加一层处理，<code>call</code>一个特定的内存地址（相对寻址）中存放的地址——存放了<code>printf</code>函数地址。如果这个<code>puts</code>地址放到<code>.data</code>段，这个段系统规定可读可写，访问这个变量就可以了，如果这些函数很多，对应的变量也很多，就可以看成表了。这也是<code>GOT</code>表的概念，<code>GOT</code>表就是存这些函数的地址，不过这些编译器帮我们做了。<code>GOT</code>表但还有一些问题，后面再说。</li><li>就刚才的问题，就算可以直接修改代码且也更改了代码，就会打破操作系统文件共用的原则，做不了所有进程共用一个动态库的原则。<br>  ==同样的，鉴于ArceOS的Unikernel的特殊性，其实完全可以这么做==。<br>  所以我们要有更巧妙的方法来解决这个问题。如果我们通过<code>PLT</code>表，放在代码段，不再改变代码，这块代码能准确指引到正确的<code>GOT</code>，第一次时还能修改<code>GOT</code>表值，做到这样的效果，好像也能解决问题，实际就是这么做的。</li></ul><p><strong>因此，<code>printf</code>函数地址只能回写到数据段，而绝不能回写到代码段上。</strong></p><p><strong>回写：</strong>是指运行时修改，更专业的称谓应该是<strong>运行时重定位</strong>，与之相对应的还有<strong>链接时重定位</strong>。</p><ul><li><p>  <strong>运行重定位：</strong>通过运行时解决了地址问题，延迟加载的动态绑定技术。</p></li><li><p>  <strong>链接重定位：</strong>编译的链接过程，就完成函数地址替换。</p></li></ul><h2 id="3-3-PLT的引入"><a href="#3-3-PLT的引入" class="headerlink" title="3.3. PLT的引入"></a>3.3. PLT的引入</h2><h3 id="3-3-1-思路分析"><a href="#3-3-1-思路分析" class="headerlink" title="3.3.1. 思路分析"></a>3.3.1. 思路分析</h3><p>根据前面讨论，运行时重定位是无法修改代码段的，只能将<code>puts</code>重定位到数据段。那在编译阶段就已生成好的call指令，怎么感知这个已重定位好的数据段内容呢？</p><p>答案是：<strong>链接器生成一段额外的小代码片段，通过这段代码获取puts函数地址，并完成对它的调用</strong>。额外代码如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.text</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> 调用puts的call指令</span><br><span class="line">call puts_stub</span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line">puts_stub:</span><br><span class="line">    mov rax, [puts函数的储存地址] <span class="string">//</span> 获取puts重定位之后的地址</span><br><span class="line">    jmp rax <span class="string">//</span> 跳过去执行puts函数</span><br><span class="line"></span><br><span class="line"><span class="string">.data</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">puts函数的储存地址：</span><br><span class="line">　　这里储存puts函数重定位后的地址</span><br></pre></td></tr></table></figure><p>链接阶段发现<code>puts</code>定义在动态库时，链接器生成一段小代码<code>puts_stub</code>，然后<code>pputs_stub</code>地址取代原来的<code>puts</code>。因此转化为链接阶段对<code>puts_stub</code>做链接重定位，而运行时才对<code>puts</code>做运行时重定位。</p><p>存放函数地址的数据表，称为全局偏移表<code>（GOT, Global Offset Table）</code>，而那个额外代码段表，称为程序链接表<code>（PLT，Procedure Link Table）</code>。</p><p><code>GOT</code>表即：全局偏移表 ，<code>Global Offset Table</code>。当动态链接库中的代码使用<code>PIC</code>模式编译出地址无关代码时，在调用方需要生成相应的<code>.got</code>段来存储函数的地址。相当于一个函数指针来寻址动态链接库中的函数，这样做的原因：把原本在<code>.text section</code>中对一个动态库中函数地址的相对地址调用，转换为从数据段<code>.got</code>中的函数指针进行间接调用，这样就可以使主模块中（只是这里举例的场景, 调用者不一定是主模块）的<code>.text section</code>的代码中的函数地址不用重定位。</p><p>当启用延时加载特性时，我们的函数的间接调用会再加一层间接调用，也就是<code>.plt</code>段。此时，调用时：<code>caller -&gt; targetFun@plt -&gt; targetFun@got.plt -&gt; 目标函数</code>。而<code>.plt</code>段的目的是提供一个特殊代码序列，当没有加载地址时，会在<code>plt</code>段顺序执行以触发延时加载。当加载完成后，以后都如上面的链条一样两次跳转后到达真正的函数。当有使用<code>.plt</code>段的时候，原来的<code>.got</code>不再存储函数的指针。此时会有另外一个类似的段来承担 相应的工作：<code>.plt.got</code>。</p><h3 id="3-3-2-代码解析"><a href="#3-3-2-代码解析" class="headerlink" title="3.3.2. 代码解析"></a>3.3.2. 代码解析</h3><p><code>.text</code>的<code>main</code>函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0000000000001149 &lt;print_banner&gt;:</span><br><span class="line">    1149:f3 0f 1e fa          endbr64 </span><br><span class="line">    114d:55                   push   %rbp</span><br><span class="line">    114e:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">    1151:48 8d 05 ac 0e 00 00 lea    0xeac(%rip),%rax        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line">    1158:48 89 c7             mov    %rax,%rdi</span><br><span class="line">    115b:e8 f0 fe ff ff       call   1050 &lt;puts@plt&gt;</span><br><span class="line">    1160:90                   nop</span><br><span class="line">    1161:5d                   pop    %rbp</span><br><span class="line">    1162:c3                   ret    </span><br><span class="line"></span><br><span class="line">0000000000001163 &lt;main&gt;:</span><br><span class="line">    1163:f3 0f 1e fa          endbr64 </span><br><span class="line">    1167:55                   push   %rbp</span><br><span class="line">    1168:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">    116b:48 8d 05 96 0e 00 00 lea    0xe96(%rip),%rax        # 2008 &lt;_IO_stdin_used+0x8&gt;</span><br><span class="line">    1172:48 89 c7             mov    %rax,%rdi</span><br><span class="line">    1175:e8 d6 fe ff ff       call   1050 &lt;puts@plt&gt;</span><br><span class="line">    117a:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">    117f:e8 c5 ff ff ff       call   1149 &lt;print_banner&gt;</span><br><span class="line">    1184:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">    1189:5d                   pop    %rbp</span><br><span class="line">    118a:c3                   ret </span><br></pre></td></tr></table></figure><p>可以看到，跳转到的是<code>&lt;puts@plt&gt;</code>，地址为<code>0150</code>。分析操作码：<code>e8 f0 fe ff ff</code>，<strong>e8，偏移跳转，而ff15是绝对跳转</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .plt.sec:</span><br><span class="line"></span><br><span class="line">0000000000001050 &lt;puts@plt&gt;:</span><br><span class="line">    1050:f3 0f 1e fa          endbr64 </span><br><span class="line">    1054:f2 ff 25 75 2f 00 00 bnd jmp *0x2f75(%rip)        # 3fd0 &lt;puts@GLIBC_2.2.5&gt;</span><br><span class="line">    105b:0f 1f 44 00 00       nopl   0x0(%rax,%rax,1)</span><br></pre></td></tr></table></figure><p>在这里，我们看到了跳转到<code>0x2f75(%rip)</code>处执行（<code>endbr64</code>和<code>bnd jmp</code>中的<code>bnd</code>都可以认为与此问题无关的），即目标地址是当前 <code>RIP</code> 的值加上 <code>0x2f75</code>。<strong>问题是，此时的rip是多少呢？</strong></p><p><code>plt</code>函数的反汇编如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">0000000000001020 &lt;.plt&gt;:</span><br><span class="line">    1020:ff 35 9a 2f 00 00    push   0x2f9a(%rip)        # 3fc0 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;</span><br><span class="line">    1026:f2 ff 25 9b 2f 00 00 bnd jmp *0x2f9b(%rip)        # 3fc8 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;</span><br><span class="line">    102d:0f 1f 00             nopl   (%rax)</span><br><span class="line">    1030:f3 0f 1e fa          endbr64 </span><br><span class="line">    1034:68 00 00 00 00       push   $0x0</span><br><span class="line">    1039:f2 e9 e1 ff ff ff    bnd jmp 1020 &lt;_init+0x20&gt;</span><br><span class="line">    103f:90                   nop</span><br></pre></td></tr></table></figure><h3 id="3-3-3-GDB调试PLT流程"><a href="#3-3-3-GDB调试PLT流程" class="headerlink" title="3.3.3. GDB调试PLT流程"></a>3.3.3. GDB调试PLT流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">1#include &lt;stdio.h&gt;</span><br><span class="line">2</span><br><span class="line">3void print_banner() &#123; printf(&quot;...\n&quot;); &#125;</span><br><span class="line">4</span><br><span class="line">5int main(void) &#123;</span><br><span class="line">6  printf(&quot;begin\n&quot;);</span><br><span class="line">7  print_banner();</span><br><span class="line">8  return 0;</span><br><span class="line">9&#125;</span><br><span class="line">(gdb) b 6</span><br><span class="line">Breakpoint 1 at 0x1151: file plt.c, line 6.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/marinatoo/tmp/plt </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at plt.c:6</span><br><span class="line">6  printf(&quot;begin\n&quot;);</span><br><span class="line">(gdb) x /5i $pc</span><br><span class="line">=&gt; 0x55555555516b &lt;main+8&gt;:</span><br><span class="line">    lea    0xe96(%rip),%rax        # 0x555555556008</span><br><span class="line">   0x555555555172 &lt;main+15&gt;:mov    %rax,%rdi</span><br><span class="line">   0x555555555175 &lt;main+18&gt;:call   0x555555555050 &lt;puts@plt&gt;</span><br><span class="line">   0x55555555517a &lt;main+23&gt;:mov    $0x0,%eax</span><br><span class="line">   0x55555555517f &lt;main+28&gt;:call   0x555555555149 &lt;print_banner&gt;</span><br><span class="line">(gdb) # 执行到call处</span><br><span class="line">(gdb) x /5i $pc</span><br><span class="line">=&gt; 0x555555555175 &lt;main+18&gt;:call   0x555555555050 &lt;puts@plt&gt;</span><br><span class="line">   0x55555555517a &lt;main+23&gt;:mov    $0x0,%eax</span><br><span class="line">   0x55555555517f &lt;main+28&gt;:call   0x555555555149 &lt;print_banner&gt;</span><br><span class="line">   0x555555555184 &lt;main+33&gt;:mov    $0x0,%eax</span><br><span class="line">   0x555555555189 &lt;main+38&gt;:pop    %rbp</span><br><span class="line">(gdb) si</span><br><span class="line">0x0000555555555050 in puts@plt ()</span><br><span class="line">(gdb) x /5i $pc</span><br><span class="line">=&gt; 0x555555555050 &lt;puts@plt&gt;:endbr64 </span><br><span class="line">   0x555555555054 &lt;puts@plt+4&gt;:bnd jmp *0x2f75(%rip)        # 0x555555557fd0 &lt;puts@got.plt&gt;</span><br><span class="line">   0x55555555505b &lt;puts@plt+11&gt;:nopl   0x0(%rax,%rax,1)</span><br><span class="line">   0x555555555060 &lt;_start&gt;:endbr64 </span><br><span class="line">   0x555555555064 &lt;_start+4&gt;:xor    %ebp,%ebp</span><br></pre></td></tr></table></figure><p>可以看出，<code>0x555555557fd0</code>是<code>puts@got.plt</code>的位置，进一步查找<code>GOT</code>表中的内存值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x /gx 0x555555557fd0</span><br><span class="line">0x555555557fd0 &lt;puts@got.plt&gt;:0x00007ffff7c80e50（这里我做不出来合适的结果，因为可能是程序在内存中保留，已经被一次执行后，got表被正确的填写且被保留）</span><br></pre></td></tr></table></figure><p>这里是第一次，并没有被填充到<code>puts</code>函数的地址，而是一路指向了<code>.plt</code>函数，而在<code>.plt</code>函数中，进行了对应的操作，然后完成了GOT的填写。由于这里我无法继续实验，附上一个能够实现的博客：<br><a href="https://blog.arg.pub/2023/04/18/linux/Linux%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%AD%E7%9A%84GOT%E5%92%8CPLT/index.html">https://blog.arg.pub/2023/04/18/linux/Linux%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%AD%E7%9A%84GOT%E5%92%8CPLT/index.html</a></p><blockquote>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 这里原文是反汇编了.plt函数</span><br><span class="line">(gdb) x /5i $pc</span><br><span class="line">=&gt; 0x401020:    pushq  0x2fe2(%rip)        # 0x404008</span><br><span class="line">   0x401026:    jmpq   *0x2fe4(%rip)        # 0x404010</span><br><span class="line">   0x40102c:    nopl   0x0(%rax)</span><br><span class="line">   0x401030 &lt;printf@plt&gt;:       jmpq   *0x2fe2(%rip)        # 0x404018 &lt;printf@got.plt&gt;</span><br><span class="line">   0x401036 &lt;printf@plt+6&gt;:     pushq  $0x0</span><br></pre></td></tr></table></figure><p>  先看一下 GOT 表对应的内存</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x /4xg 0x404000</span><br><span class="line">0x404000:       0x0000000000403e20      0x00007fffff7df190</span><br><span class="line">0x404010:       0x00007fffff7c8bb0      0x0000000000401036</span><br></pre></td></tr></table></figure><p>  同上面分析 RIP 偏移法，将 0x404008h 地址所对应的内容放到栈中，然后跳转到 0x404010 来执行，我们看一下这一内存的值，然后跳转到了 ld-linux-x86-64.so.2 这个 so 我们调用完，就是将 printf 函数的地址，写入到 Got 表中，404018 <a href="mailto:printf@GLIBC_2.2.5">printf@GLIBC_2.2.5</a>，GOT 表以 404000 开始，我们是 64 位的，也就是偏移 + 3 的地方，第 4 个数据。这里我们有些问题，为什么放到表中第 4 个数据呢？我们再观察一下前面的.plt 段，就会发现，printf 对应 push 0,memset 对应 push 1，按理论应该 printf 放到 GOT 表中第一项，memset 放到表中第 2 项，实际是因为 GOT 表中前三项已被占用了，有特别的用处。 GOT [0]: 自身模块的 dynamic 段地址，这里是 0x0000000000403e20， GOT [1]: 本模块的 link_map 地址，这里是 0x00007fffff7df190 GOT [2]: 系统模块中的_dl_runtime_resolve 函数地址，这里是 0x00007fffff7c8bb0 所以 printf 函数地址放到 GOT [3], 从第 4 项开始，是正常的，这里第一次是 0x0000000000401036。</p><p>  从这里我们明白了，jmpq *0x2fe4 (% rip) 就是跳到了 GOT [2] 中_dl_runtime_resolve 的函数里面了，这个函数在 linux 的库中，算也挺复杂的，这里调用完这个函数，会将 printf 的地址写到 GOT [3] 中，并跳转到 printf 函数执行。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//调用形式为：</span><br><span class="line">_dl_runtime_resolve((link_map*)(got[1]),0);</span><br><span class="line">// 第一个参数为.plt开头处刚刚0x401026:    jmpq   *0x2fe4(%rip)        # 0x404010</span><br><span class="line">// 地址为got[1]的值，也就是0x00007fffff7df190</span><br><span class="line"></span><br><span class="line">// 第二个参数0，为&lt;printf@plt&gt;:中push 0；</span><br><span class="line">// 0x401036 &lt;printf@plt+6&gt;:     pushq  $0x0</span><br><span class="line">// 同理如果是memset,就是&lt;memset@plt&gt;:中push 1；</span><br><span class="line">// 0x401046 &lt;memset@plt+6&gt;:    pushq  $0x1</span><br></pre></td></tr></table></figure><p>  我们看一下内存，注意 GOT [3] 已经被写成了 0x00007fffff614e10，为 printf 的函数内存地址</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x /4xg 0x404000</span><br><span class="line">0x404000:       0x0000000000403e20      0x00007fffff7df190</span><br><span class="line">0x404010:       0x00007fffff7c8bb0      0x00007fffff614e10</span><br></pre></td></tr></table></figure><p>  为了这个，我们可以设置条件断点来监视一下，从此当我们下次调用 printf 函数，就不再走这一大圈的流程，直接就会调到 GOT [3] 中真正的 printf 地址。</p><p>  GOT 表数据第一次填充： 进程从二进制装载时，GOT 表函数第一次是被 ld-linux-x86-64.so.2 填充为.plt 表中地址，然后直到调用真正函数，才像上面分析的那样，填充为真正的函数地址。</p></blockquote><p>我只能通过<code>bless</code>工具直接查看：<br><img src="http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250112181730737.png" alt="image-20250112181730737"></p><p><img src="http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250112181739291.png" alt="image-20250112181739291"></p><p>根据加载进入的偏移量，直接查询<code>GOT</code>：（偏移量为<code>0x555555554000</code>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x /10gx 0x555555557FB8</span><br><span class="line">0x555555557fb8:0x0000000000003dc80x0000000000000000</span><br><span class="line">0x555555557fc8:0x00000000000000000x00007ffff7c80e50（这个就是puts函数的位置）</span><br><span class="line">0x555555557fd8:0x00007ffff7c29dc00x0000000000000000</span><br><span class="line">0x555555557fe8:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555557ff8:0x00007ffff7c459a00x0000000000000000</span><br></pre></td></tr></table></figure><p><del>可以看到，其实原始的<code>GOT</code>中<code>GOT[0], GOT[1], GOT[2]</code>的值与执行开始的时候是不一样的，<strong>推测是Linux加载的过程中修改的</strong>。</del></p><p>这个是错误想法，恰恰相反，是因为我没有开启延迟加载才导致出现了这种情况。</p><h2 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4. 总结"></a>3.4. 总结</h2><p>plt 和 got 配合的延迟绑定加载，可以降低程序的启动时间，只有外部函数被调用了才真正动态加载，只需要加载一次，后续再调用，无需重复，但略为增加了开销，最致命的是，GOT 表是可写的，<strong>可以被外挂利用起来，达到替换函数攻击</strong>。==而这个就是我目前存在的想法，通过在执行<code>loader.rs</code>加载可执行文件进入内存的时候，将<code>GOT</code>表进行重写，然后执行自己的函数==</p><p>==问题==：我们需要了解<code>_dl_runtime_resolve</code>做了什么，并且尝试在ArceOS中替换这个函数，实现对<code>GOT</code>的填写。同时还要注意，<code>ld-linux-x86-64.so.2</code>是一个及其重要的东西。</p><p>==截止目前，我能想到的思路就是，可以在加载的时候直接修改<code>GOT</code>，替换上述函数，或者是直接修改PLT函数，用自定义的PLT函数指定修改OPT==</p><p>附录：整个<code>plt.c</code>编译出的汇编如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">plt：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .init:</span><br><span class="line"></span><br><span class="line">0000000000001000 &lt;_init&gt;:</span><br><span class="line">    1000:f3 0f 1e fa          endbr64 </span><br><span class="line">    1004:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">    1008:48 8b 05 d9 2f 00 00 mov    0x2fd9(%rip),%rax        # 3fe8 &lt;__gmon_start__@Base&gt;</span><br><span class="line">    100f:48 85 c0             test   %rax,%rax</span><br><span class="line">    1012:74 02                je     1016 &lt;_init+0x16&gt;</span><br><span class="line">    1014:ff d0                call   *%rax</span><br><span class="line">    1016:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">    101a:c3                   ret    </span><br><span class="line"></span><br><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">0000000000001020 &lt;.plt&gt;:</span><br><span class="line">    1020:ff 35 9a 2f 00 00    push   0x2f9a(%rip)        # 3fc0 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;</span><br><span class="line">    1026:f2 ff 25 9b 2f 00 00 bnd jmp *0x2f9b(%rip)        # 3fc8 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;</span><br><span class="line">    102d:0f 1f 00             nopl   (%rax)</span><br><span class="line">    1030:f3 0f 1e fa          endbr64 </span><br><span class="line">    1034:68 00 00 00 00       push   $0x0</span><br><span class="line">    1039:f2 e9 e1 ff ff ff    bnd jmp 1020 &lt;_init+0x20&gt;</span><br><span class="line">    103f:90                   nop</span><br><span class="line"></span><br><span class="line">Disassembly of section .plt.got:</span><br><span class="line"></span><br><span class="line">0000000000001040 &lt;__cxa_finalize@plt&gt;:</span><br><span class="line">    1040:f3 0f 1e fa          endbr64 </span><br><span class="line">    1044:f2 ff 25 ad 2f 00 00 bnd jmp *0x2fad(%rip)        # 3ff8 &lt;__cxa_finalize@GLIBC_2.2.5&gt;</span><br><span class="line">    104b:0f 1f 44 00 00       nopl   0x0(%rax,%rax,1)</span><br><span class="line"></span><br><span class="line">Disassembly of section .plt.sec:</span><br><span class="line"></span><br><span class="line">0000000000001050 &lt;puts@plt&gt;:</span><br><span class="line">    1050:f3 0f 1e fa          endbr64 </span><br><span class="line">    1054:f2 ff 25 75 2f 00 00 bnd jmp *0x2f75(%rip)        # 3fd0 &lt;puts@GLIBC_2.2.5&gt;</span><br><span class="line">    105b:0f 1f 44 00 00       nopl   0x0(%rax,%rax,1)</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000001060 &lt;_start&gt;:</span><br><span class="line">    1060:f3 0f 1e fa          endbr64 </span><br><span class="line">    1064:31 ed                xor    %ebp,%ebp</span><br><span class="line">    1066:49 89 d1             mov    %rdx,%r9</span><br><span class="line">    1069:5e                   pop    %rsi</span><br><span class="line">    106a:48 89 e2             mov    %rsp,%rdx</span><br><span class="line">    106d:48 83 e4 f0          and    $0xfffffffffffffff0,%rsp</span><br><span class="line">    1071:50                   push   %rax</span><br><span class="line">    1072:54                   push   %rsp</span><br><span class="line">    1073:45 31 c0             xor    %r8d,%r8d</span><br><span class="line">    1076:31 c9                xor    %ecx,%ecx</span><br><span class="line">    1078:48 8d 3d e4 00 00 00 lea    0xe4(%rip),%rdi        # 1163 &lt;main&gt;</span><br><span class="line">    107f:ff 15 53 2f 00 00    call   *0x2f53(%rip)        # 3fd8 &lt;__libc_start_main@GLIBC_2.34&gt;</span><br><span class="line">    1085:f4                   hlt    </span><br><span class="line">    1086:66 2e 0f 1f 84 00 00 cs nopw 0x0(%rax,%rax,1)</span><br><span class="line">    108d:00 00 00 </span><br><span class="line"></span><br><span class="line">0000000000001090 &lt;deregister_tm_clones&gt;:</span><br><span class="line">    1090:48 8d 3d 79 2f 00 00 lea    0x2f79(%rip),%rdi        # 4010 &lt;__TMC_END__&gt;</span><br><span class="line">    1097:48 8d 05 72 2f 00 00 lea    0x2f72(%rip),%rax        # 4010 &lt;__TMC_END__&gt;</span><br><span class="line">    109e:48 39 f8             cmp    %rdi,%rax</span><br><span class="line">    10a1:74 15                je     10b8 &lt;deregister_tm_clones+0x28&gt;</span><br><span class="line">    10a3:48 8b 05 36 2f 00 00 mov    0x2f36(%rip),%rax        # 3fe0 &lt;_ITM_deregisterTMCloneTable@Base&gt;</span><br><span class="line">    10aa:48 85 c0             test   %rax,%rax</span><br><span class="line">    10ad:74 09                je     10b8 &lt;deregister_tm_clones+0x28&gt;</span><br><span class="line">    10af:ff e0                jmp    *%rax</span><br><span class="line">    10b1:0f 1f 80 00 00 00 00 nopl   0x0(%rax)</span><br><span class="line">    10b8:c3                   ret    </span><br><span class="line">    10b9:0f 1f 80 00 00 00 00 nopl   0x0(%rax)</span><br><span class="line"></span><br><span class="line">00000000000010c0 &lt;register_tm_clones&gt;:</span><br><span class="line">    10c0:48 8d 3d 49 2f 00 00 lea    0x2f49(%rip),%rdi        # 4010 &lt;__TMC_END__&gt;</span><br><span class="line">    10c7:48 8d 35 42 2f 00 00 lea    0x2f42(%rip),%rsi        # 4010 &lt;__TMC_END__&gt;</span><br><span class="line">    10ce:48 29 fe             sub    %rdi,%rsi</span><br><span class="line">    10d1:48 89 f0             mov    %rsi,%rax</span><br><span class="line">    10d4:48 c1 ee 3f          shr    $0x3f,%rsi</span><br><span class="line">    10d8:48 c1 f8 03          sar    $0x3,%rax</span><br><span class="line">    10dc:48 01 c6             add    %rax,%rsi</span><br><span class="line">    10df:48 d1 fe             sar    %rsi</span><br><span class="line">    10e2:74 14                je     10f8 &lt;register_tm_clones+0x38&gt;</span><br><span class="line">    10e4:48 8b 05 05 2f 00 00 mov    0x2f05(%rip),%rax        # 3ff0 &lt;_ITM_registerTMCloneTable@Base&gt;</span><br><span class="line">    10eb:48 85 c0             test   %rax,%rax</span><br><span class="line">    10ee:74 08                je     10f8 &lt;register_tm_clones+0x38&gt;</span><br><span class="line">    10f0:ff e0                jmp    *%rax</span><br><span class="line">    10f2:66 0f 1f 44 00 00    nopw   0x0(%rax,%rax,1)</span><br><span class="line">    10f8:c3                   ret    </span><br><span class="line">    10f9:0f 1f 80 00 00 00 00 nopl   0x0(%rax)</span><br><span class="line"></span><br><span class="line">0000000000001100 &lt;__do_global_dtors_aux&gt;:</span><br><span class="line">    1100:f3 0f 1e fa          endbr64 </span><br><span class="line">    1104:80 3d 05 2f 00 00 00 cmpb   $0x0,0x2f05(%rip)        # 4010 &lt;__TMC_END__&gt;</span><br><span class="line">    110b:75 2b                jne    1138 &lt;__do_global_dtors_aux+0x38&gt;</span><br><span class="line">    110d:55                   push   %rbp</span><br><span class="line">    110e:48 83 3d e2 2e 00 00 cmpq   $0x0,0x2ee2(%rip)        # 3ff8 &lt;__cxa_finalize@GLIBC_2.2.5&gt;</span><br><span class="line">    1115:00 </span><br><span class="line">    1116:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">    1119:74 0c                je     1127 &lt;__do_global_dtors_aux+0x27&gt;</span><br><span class="line">    111b:48 8b 3d e6 2e 00 00 mov    0x2ee6(%rip),%rdi        # 4008 &lt;__dso_handle&gt;</span><br><span class="line">    1122:e8 19 ff ff ff       call   1040 &lt;__cxa_finalize@plt&gt;</span><br><span class="line">    1127:e8 64 ff ff ff       call   1090 &lt;deregister_tm_clones&gt;</span><br><span class="line">    112c:c6 05 dd 2e 00 00 01 movb   $0x1,0x2edd(%rip)        # 4010 &lt;__TMC_END__&gt;</span><br><span class="line">    1133:5d                   pop    %rbp</span><br><span class="line">    1134:c3                   ret    </span><br><span class="line">    1135:0f 1f 00             nopl   (%rax)</span><br><span class="line">    1138:c3                   ret    </span><br><span class="line">    1139:0f 1f 80 00 00 00 00 nopl   0x0(%rax)</span><br><span class="line"></span><br><span class="line">0000000000001140 &lt;frame_dummy&gt;:</span><br><span class="line">    1140:f3 0f 1e fa          endbr64 </span><br><span class="line">    1144:e9 77 ff ff ff       jmp    10c0 &lt;register_tm_clones&gt;</span><br><span class="line"></span><br><span class="line">0000000000001149 &lt;print_banner&gt;:</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void print_banner() &#123; printf(&quot;...\n&quot;); &#125;</span><br><span class="line">    1149:f3 0f 1e fa          endbr64 </span><br><span class="line">    114d:55                   push   %rbp</span><br><span class="line">    114e:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">    1151:48 8d 05 ac 0e 00 00 lea    0xeac(%rip),%rax        # 2004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line">    1158:48 89 c7             mov    %rax,%rdi</span><br><span class="line">    115b:e8 f0 fe ff ff       call   1050 &lt;puts@plt&gt;</span><br><span class="line">    1160:90                   nop</span><br><span class="line">    1161:5d                   pop    %rbp</span><br><span class="line">    1162:c3                   ret    </span><br><span class="line"></span><br><span class="line">0000000000001163 &lt;main&gt;:</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    1163:f3 0f 1e fa          endbr64 </span><br><span class="line">    1167:55                   push   %rbp</span><br><span class="line">    1168:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">  printf(&quot;begin\n&quot;);</span><br><span class="line">    116b:48 8d 05 96 0e 00 00 lea    0xe96(%rip),%rax        # 2008 &lt;_IO_stdin_used+0x8&gt;</span><br><span class="line">    1172:48 89 c7             mov    %rax,%rdi</span><br><span class="line">    1175:e8 d6 fe ff ff       call   1050 &lt;puts@plt&gt;</span><br><span class="line">  print_banner();</span><br><span class="line">    117a:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">    117f:e8 c5 ff ff ff       call   1149 &lt;print_banner&gt;</span><br><span class="line">  return 0;</span><br><span class="line">    1184:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">&#125;</span><br><span class="line">    1189:5d                   pop    %rbp</span><br><span class="line">    118a:c3                   ret    </span><br><span class="line"></span><br><span class="line">Disassembly of section .fini:</span><br><span class="line"></span><br><span class="line">000000000000118c &lt;_fini&gt;:</span><br><span class="line">    118c:f3 0f 1e fa          endbr64 </span><br><span class="line">    1190:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">    1194:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">    1198:c3                   ret</span><br></pre></td></tr></table></figure><h1 id="4-ELF文件格式"><a href="#4-ELF文件格式" class="headerlink" title="4. ELF文件格式"></a>4. ELF文件格式</h1><h2 id="4-1-ELF中的各个节区"><a href="#4-1-ELF中的各个节区" class="headerlink" title="4.1. ELF中的各个节区"></a>4.1. ELF中的各个节区</h2><p>ELF节区信息概述</p><table><thead><tr><th align="center">节区名</th><th>节区说明</th><th align="left">备注</th></tr></thead><tbody><tr><td align="center">.rodata1</td><td>和rodata类似，只存放只读数据</td><td align="left"></td></tr><tr><td align="center">.comment</td><td>存放编译器版本信息，如字符串 “GCC:(GNU)4.2.0”</td><td align="left"></td></tr><tr><td align="center">.debug</td><td>存放调试信息</td><td align="left"></td></tr><tr><td align="center">.shstrtab</td><td>节区头部表名字的字符串表(Section Header String Table)</td><td align="left"></td></tr><tr><td align="center">.plt</td><td>过程链接表(Procedure Linkage Table),用来保存长跳转格式的函数调用</td><td align="left"></td></tr><tr><td align="center">.got</td><td>全局偏移表(Global Offset Table)，在地址无关代码中才需要，所有只读段需要修复的位置都间接引用到此表, 因此只读段自身就无需修复，只需修复此got表即可.<br/>.got表是在编译期间确定，静态链接期间生成的<br/>而.plt表是在静态链接期间确定，静态链接期间生成的</td><td align="left">可执行文件通常不论如何编译都有got表，这是因为是否加入got表是由编译(cc1)期间决定的，而可执行文件默认连接的多个目标文件默认都有got表元素.</td></tr><tr><td align="center">.got.plt</td><td>实际上其本质是从.got表中拆除来的一部分，当开启延迟绑定(Lazy Binding)时，会将plt表中的长跳转(函数)的重定位信息单独放到此表中，以满足后续实际的延迟绑定.</td><td align="left"></td></tr><tr><td align="center">.symtab</td><td>(静态链接)符号表的作用是保存当前 目标文件中所有对符号的定义和引用.<br/>* 符号表中UND的符号不是当前目标文件定义的，也就是对符号的引用<br/>* 符号表中其他非UND的符号，全部是定义在当前目标文件中的，也就是对符号的定义</td><td align="left">默认所有非.L开头的符号都要输出，.L开头的不输出</td></tr><tr><td align="center">.strtab</td><td>静态链接字符串表，其中记录的是静态链接符号表中使用到的字符串，这些字符串仅供静态链接符号表使用，strip的时候会将.symtab和.strtab两个段完全清除.</td><td align="left">符号表的第一个元素必须是 <strong>STN_UNDEF，</strong>其代表一个未定义的符号索引，此符号表项内部所有值都为0</td></tr><tr><td align="center">.group</td><td>是用来记录多个节区的相关信息的，比如说代码段引用了数据段，这种信息是为了保证二进制处理时候不会操作错误的，像是elf自动生成的，细节见链接</td><td align="left"></td></tr></tbody></table><p>动态链接相关节区：</p><table><thead><tr><th align="center">节区名</th><th align="left">节区说明</th><th align="left">备注</th></tr></thead><tbody><tr><td align="center">.interp</td><td align="left">.interp整个段的内容就是一个字符串，此字符串为系统中动态链接器的路径，如：<br/>/lib/ld-linux-aarch64.so.1<br />linux的可执行文件加载时会去寻找可执行文件所需的动态链接器</td><td align="left"></td></tr><tr><td align="center">.dynamic</td><td align="left">.interp保存的是动态链接器路径，.dynamic中保存的是动态链接器用到的基本信息,如动态链接符号表(.dynsym)，字符串表(.dynstr),重定位表(.rela.dyn/rela.plt),依赖的运行时库，库查找路径等</td><td align="left"></td></tr><tr><td align="center">.rela.dyn</td><td align="left">记录所有变量的动态链接重定位信息（.rela.plt记录的是函数），与.rela.plt一起，是系统中唯二的两张动态链接重定位表。<br/>.rela.dyn记录除了.plt段之外所有段的动态链接重定位信息，若开启了地址无关代码，那么这些信息都应该只与.got段的地址有关.</td><td align="left"></td></tr><tr><td align="center">.rela.plt</td><td align="left">过程连接表的动态链接重定位表，只要有过程链表，通常就会有此表，因为plt导致了绝对跳转，那么所有plt表中所有需要动态链接/重定位的绝对地址(可能在.got.plt或.got中，依赖于是否开启延迟绑定),都需要通过.rela.plt记录  <br/>  此表中记录所有全局函数(长跳转函数)的动态链接重定位信息，与.rela.dyn一起，是系统中唯二的两张动态链接重定位表。<br/>.rela.plt实际上记录的是.plt段的动态链接重定位信息，若未开启lazy binding,则这这些信息应该都只与.got段的地址有关；若开启lazy binding,则这些信息应该都只与.got.plt段的地址有关;</td><td align="left">需要动态链接重定位的原因主要是模块有导入符号的存在,这些符号在运行时才能确定, 地址无关代码并不能改变未定符号的本质(即不影响模块是否需要动态链接重定位), 但地址无关代码可以让重定位变得简单(如仅重定位 .got/ .data/ .got.plt)</td></tr><tr><td align="center">.dynsym</td><td align="left">动态链接符号表，其格式和.symtab一样，readelf -s会尝试同时输出.dynsym和.symtab，如右图.<br/>  动态链接符号表是静态链接符号表的子集，其只保留了与动态链接相关的符号信息，所有模块内部符号则不保留(因此静态符号表是可以被strip的，其只对于目标文件有用).<br/>  动态链接符号表中未定义的符号(符号引用),又称为导入符号(类似导入表)<br/>  动态链接符号表中已定义的符号(符号定义),又称为导出符号(类似导出表)</td><td align="left">全局符号默认是直接导出到动态链接重定位表的</td></tr><tr><td align="center">.dynstr</td><td align="left">动态链接符号表用到的字符串表，其与静态链接字符串表(.strtab)分开的原因应该是.strtab是可以完全strip的</td><td align="left"></td></tr></tbody></table><p>参考文章：<br><a href="https://blog.csdn.net/weixin_46645965/article/details/136506249">https://blog.csdn.net/weixin_46645965/article/details/136506249</a></p><p><a href="https://blog.csdn.net/xuehuafeiwu123/article/details/72963229">https://blog.csdn.net/xuehuafeiwu123/article/details/72963229</a></p><p><a href="https://blog.csdn.net/qq_36488756/article/details/129462449">https://blog.csdn.net/qq_36488756/article/details/129462449</a></p><p><a href="https://blog.csdn.net/passenger12234/article/details/123429547">https://blog.csdn.net/passenger12234/article/details/123429547</a></p><p><a href="https://blog.csdn.net/lidan113lidan/article/details/119901186">https://blog.csdn.net/lidan113lidan/article/details/119901186</a></p><h2 id="4-2-ELF的结构体"><a href="#4-2-ELF的结构体" class="headerlink" title="4.2. ELF的结构体"></a>4.2. ELF的结构体</h2><h3 id="4-2-1-ELF-header"><a href="#4-2-1-ELF-header" class="headerlink" title="4.2.1. ELF header"></a>4.2.1. ELF header</h3><p>64位和32位ELF文件头结构包含了同名的成员域，只是某些成员域的长度不同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EI_NIDENT 16</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[EI_NIDENT];</span><br><span class="line">    <span class="keyword">uint16_t</span>      e_type;</span><br><span class="line">    <span class="keyword">uint16_t</span>      e_machine;</span><br><span class="line">    <span class="keyword">uint32_t</span>      e_version;</span><br><span class="line">    ElfN_Addr     e_entry;</span><br><span class="line">    ElfN_Off      e_phoff;</span><br><span class="line">    ElfN_Off      e_shoff;</span><br><span class="line">    <span class="keyword">uint32_t</span>      e_flags;</span><br><span class="line">    <span class="keyword">uint16_t</span>      e_ehsize;</span><br><span class="line">    <span class="keyword">uint16_t</span>      e_phentsize;</span><br><span class="line">    <span class="keyword">uint16_t</span>      e_phnum;</span><br><span class="line">    <span class="keyword">uint16_t</span>      e_shentsize;</span><br><span class="line">    <span class="keyword">uint16_t</span>      e_shnum;</span><br><span class="line">    <span class="keyword">uint16_t</span>      e_shstrndx;</span><br><span class="line">&#125; ElfN_Ehdr;</span><br></pre></td></tr></table></figure><h4 id="4-2-1-1-基本类型"><a href="#4-2-1-1-基本类型" class="headerlink" title="4.2.1.1. 基本类型"></a>4.2.1.1. 基本类型</h4><p>以下类型用于N位体系结构(N = 32,64，ElfN代表Elf32或<em>Elf64</em>，uintN_t代表uint32_t或uint64_t)</p><blockquote><p>  Elf64_Addr（作用为Unsigned program address，表示程序内的地址，无符号）为8字节长，ELF32_Addr为4字节，等同于64或32位平台的指针类型。<br>  Elf64_Off（作用为Unsigned file offset，表示文件偏移量，无符号）为8字节长（等同于64位平台的long），Elf32_Off为4字节（等同于32位平台的int）。<br>  Elf64_Half（作用为Unsigned medium integer，表示中等大小的整数，无符号）和Elf32_Half都是2字节，  uint16_t。<br>  Elf64_Word（作用为Unsigned integer，无符号整型）和Elf32_Word都是4字节，等同于int32_t。</p></blockquote><h4 id="4-2-1-2-e-ident"><a href="#4-2-1-2-e-ident" class="headerlink" title="4.2.1.2. e_ident"></a>4.2.1.2. e_ident</h4><blockquote><p>  e_ident[0-3]：前4个元素构成魔幻数（Magic Number），取值分别为’0x7f’、’E’、’L’、’F’。<br>  e_ident[EL_CLASS=4]：ELF文件是32位的（取值为1）还是64位的（取值为2）。<br>  e_ident[EL_DATA=5]：数据的字节序是小端（Little Endian，取值为1）还是大端（Big Endian，取值为2）。<br>  e_ident[EL_VERSION=6]：ELF文件版本，正常情况下该元素取值为1。<br>  e_ident其余元素为字节对齐用。</p></blockquote><h4 id="4-2-1-3-e-type"><a href="#4-2-1-3-e-type" class="headerlink" title="4.2.1.3. e_type"></a>4.2.1.3. e_type</h4><p>该成员域的长度为2个字节（类型为Elf64_Half），指明ELF文件的类型。</p><h4 id="4-2-1-4-e-machine"><a href="#4-2-1-4-e-machine" class="headerlink" title="4.2.1.4. e_machine"></a>4.2.1.4. e_machine</h4><p>该成员域长度也为2个字节，指明该ELF文件对应哪种CPU架构。</p><h4 id="4-2-1-5-e-flags"><a href="#4-2-1-5-e-flags" class="headerlink" title="4.2.1.5. e_flags"></a>4.2.1.5. e_flags</h4><p>和处理器相关的标识。其取值和解释依赖e_machine</p><p>以ARM平台为例，介绍它的取值情况。</p><ul><li>  在ARM32位平台（e_machine被定义为标记符EM_ARM，值为40）上，e_flags取值为0x02（标记符为EF_ARM_HASENTY），表示该ELF文件包含有效e_entry值。为什么头结构中已经定义了e_entry，而ARM平台上还需要这个参数呢？原来，在ARM平台上，e_entry取值可以为0。而这和ELF规范中ELF文件头结构的e_entry为0表示没有e_entry的含义相冲突。所以在ARM平台上，e_entry为0的真正含义就由e_flags来决定。</li><li>  在ARM64位平台（e_machine取值为183，标记符为EM_AARCH64）上，e_flags就没有特殊的取值</li></ul><h4 id="4-2-1-6-e-version"><a href="#4-2-1-6-e-version" class="headerlink" title="4.2.1.6. e_version"></a>4.2.1.6. e_version</h4><p>该成员取值同e_ident[EL_VERSION]。</p><h4 id="4-2-1-7-e-entry"><a href="#4-2-1-7-e-entry" class="headerlink" title="4.2.1.7. e_entry"></a>4.2.1.7. e_entry</h4><p>如果ELF文件是一个可执行程序的话，操作系统加载它后将跳转到e_entry的位置去执行该程序的代码。e_entry是虚拟内存地址，不是实际内存地址</p><h4 id="4-2-1-8-e-phoff"><a href="#4-2-1-8-e-phoff" class="headerlink" title="4.2.1.8. e_phoff"></a>4.2.1.8. e_phoff</h4><p>ph是program header的缩写。由图4-1可知，program header table是执行视图中必须要包含的信息。e_phoff指明ph table在该ELF文件的起始位置（从文件头开始算起的偏移量）。</p><h4 id="4-2-1-9-e-shoff"><a href="#4-2-1-9-e-shoff" class="headerlink" title="4.2.1.9. e_shoff"></a>4.2.1.9. e_shoff</h4><p>sh是section header的缩写。同e_phoff类似，如果该ELF文件包含sh table的话，该成员域指明sh table在文件的起始位置。</p><h4 id="4-2-1-10-e-ehsize"><a href="#4-2-1-10-e-ehsize" class="headerlink" title="4.2.1.10. e_ehsize"></a>4.2.1.10. e_ehsize</h4><p>eh是elf header的缩写。该成员域表示ELF文件头结构的长度，64位ELF文件头结构长度为64。</p><h4 id="4-2-1-11-e-phentsize和e-phnum"><a href="#4-2-1-11-e-phentsize和e-phnum" class="headerlink" title="4.2.1.11. e_phentsize和e_phnum"></a>4.2.1.11. e_phentsize和e_phnum</h4><p>这两个成员域指明ph table中每个元素的长度和该table中包含多少个元素。注意，ph表元素的长度是固定的，由此可计算ph table的大小是e_phentsize(ph entry size，每个元素的长度)×e_phnum（entry number，元素个数）。</p><h4 id="4-2-1-12-e-shentsize和e-shum"><a href="#4-2-1-12-e-shentsize和e-shum" class="headerlink" title="4.2.1.12. e_shentsize和e_shum"></a>4.2.1.12. e_shentsize和e_shum</h4><p>说明sh table中每个元素的长度以及sh table中包含多少个元素</p><h4 id="4-2-1-13-e-shstrndx"><a href="#4-2-1-13-e-shstrndx" class="headerlink" title="4.2.1.13. e_shstrndx"></a>4.2.1.13. e_shstrndx</h4><p>根据ELF规范，每个section都会有一个名字（用字符串表示）。这些字符串存储在一个类型为String的section里。这个section在sh table中的索引号就是e_shstrndx。</p><h3 id="4-2-2-Program-Header-Table"><a href="#4-2-2-Program-Header-Table" class="headerlink" title="4.2.2. Program Header Table"></a>4.2.2. Program Header Table</h3><p>Execution View中ELF必须包含Program Header Table，PH Table描述的是segment的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>   p_type;     <span class="meta">#segmentt标记符</span></span><br><span class="line">    <span class="keyword">uint32_t</span>   p_flags;    <span class="meta">#segment标记符</span></span><br><span class="line">    Elf64_Off  p_offset;   #该segment位于文件的起始位置</span><br><span class="line">    Elf64_Addr p_vaddr;    #该segment加载到进程虚拟内存空间时指定的内存地址。</span><br><span class="line">    Elf64_Addr p_paddr;    #该segment对应的物理地址。</span><br><span class="line">    <span class="keyword">uint64_t</span>   p_filesz;   #该segment在文件中占据的大小，其值可以为<span class="number">0</span></span><br><span class="line">    <span class="keyword">uint64_t</span>   p_memsz;    <span class="meta">#segment在内存中占据的空间，其值可以为0</span></span><br><span class="line">    <span class="keyword">uint64_t</span>   p_align;    <span class="meta">#segment加载到内存后其首地址需要按p_align的要求进行对齐</span></span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure><p>查看PH Table：<code>readelf -l a.out</code></p><h3 id="4-2-3-Section-Header-Table"><a href="#4-2-3-Section-Header-Table" class="headerlink" title="4.2.3. Section Header Table"></a>4.2.3. Section Header Table</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Wordsh_name;</span><br><span class="line">    Elf64_Wordsh_type;</span><br><span class="line">    Elf64_Xwordsh_flags;</span><br><span class="line">    Elf64_Addrsh_addr;</span><br><span class="line">    Elf64_Offsh_offset;</span><br><span class="line">    Elf64_Xwordsh_size;</span><br><span class="line">    Elf64_Wordsh_link;</span><br><span class="line">    Elf64_Wordsh_info;</span><br><span class="line">    Elf64_Xwordsh_addralign;</span><br><span class="line">    Elf64_Xwordsh_entsize;</span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure><blockquote><p>sh_name：每个section都有一个名字。ELF有一个专门存储Section名字的Section（Section Header String Table Section，简写为shstrtab）。这里的sh_name指向shstrtab的某个位置，该位置存储了本Section名字的字符串。sh_type：section的类型，不同类型的Section存储不同的内容。比如.shstrtab的类型就是SHT_STRTAB，它存储字符串。</p><p>sh_flags：Section的属性。下文将详细介绍sh_type和sh_flags。</p><p>sh_addr：如果该Section被加载到内存的话（可执行程序或动态库），sh_addr指明应该加载到内存什么位置（进程的虚拟地址空间）。</p><p>sh_offset：表明该Section真正的内容在文件什么位置。</p><p>sh_size：section本身的大小。不同类型的Section分别对应不同的数据结构。</p></blockquote><p>查看 Section Header Table</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">readelf --sections main.o</span><br><span class="line">或</span><br><span class="line">readelf -S main.o</span><br></pre></td></tr></table></figure><p>根据ELF规范，sh table表第0项是占位用的，所以其值全为0</p><h4 id="4-2-3-1-shstrtab-section"><a href="#4-2-3-1-shstrtab-section" class="headerlink" title="4.2.3.1. .shstrtab section"></a>4.2.3.1. .shstrtab section</h4><p>Section Header String Table的简写，Section的名字是字符串，这些字符串信息存储在Section Header String Table中</p><p>将指定名字或索引的section的内容转换成字符信息打印出来：<code>readelf -p [section名|section索引] main.o</code></p><h4 id="4-2-3-2-text-section"><a href="#4-2-3-2-text-section" class="headerlink" title="4.2.3.2. .text section"></a>4.2.3.2. .text section</h4><p>用于存储程序的指令</p><p>.text section的sh_type为SHT_PROGBITS（取值为1），意为Program Bits，即完全由应用程序自己决定（程序的机器指令当然是由程序自己决定的），sh_flags为SHF_ALLOC（当ELF文件加载到内存时，表示该Section会分配内存）和SHF_EXECINSTR（表示该Section包含可执行的机器指令）</p><p>用 “objdump-S-d main.o”可反编译.text的内容。”-S”参数表示结合源码进行反汇编。这要求编译main.o的时候使用gcc-g参数。</p><h4 id="4-2-3-3-bss-section"><a href="#4-2-3-3-bss-section" class="headerlink" title="4.2.3.3. .bss section"></a>4.2.3.3. .bss section</h4><p>block storage segment的缩写</p><p>.bss section包含了一块内存区域，这块区域在ELF文件被加载到进程空间时会由系统创建并设置这块内存的内容为0。注意，.bss section在ELF文件里不占据任何文件的空间，所以其sh_type为SHF_NOBITS（取值为8）</p><p>.bss的sh_flags取值必须为SHF_ALLOC和SHF_WRITE（表示该区域的内存是可写的。同时，因为该区域要初始化为0，所以要求该区域内存可写）。</p><p>打印指定section的内容<code>readelf -x section名 main.o</code></p><h4 id="4-2-3-4-data-section"><a href="#4-2-3-4-data-section" class="headerlink" title="4.2.3.4. .data section"></a>4.2.3.4. .data section</h4><p>.data和.bss类似，但是它包含的数据不会初始化为0。这种情况下就需要在文件中包含对应的信息了。所以.data的sh_type为SHF_PROGBITS，但sh_flags和.bss一样。读者可以尝试在main.c中定义一个比如”char c=’f’”这样的变量就能看到.data section的变化了。</p><h4 id="4-2-3-5-rodata-section"><a href="#4-2-3-5-rodata-section" class="headerlink" title="4.2.3.5. .rodata section"></a>4.2.3.5. .rodata section</h4><p>包含只读数据的信息，比如main.c中printf里的字符串就属于这一类。它的sh_flags只能为SHF_ALLOC。</p><h4 id="4-2-3-6-symtab-section"><a href="#4-2-3-6-symtab-section" class="headerlink" title="4.2.3.6. .symtab section"></a>4.2.3.6. .symtab section</h4><p>里边存储的是符号表（Symbol Table）。.symtab section的类型为SHT_SYMTAB。<strong>一般而言，符号表主要用于编译链接，也可以参与动态库的加载。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Wordst_name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>st_info;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>st_other;</span><br><span class="line">    Elf64_Halfst_shndx;</span><br><span class="line">    Elf64_Addrst_value;</span><br><span class="line">    Elf64_Xwordst_size;</span><br><span class="line">&#125; Elf64_Sym;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_ST_BIND(info)((info) &gt;&gt; 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_ST_TYPE(info)((info) &amp; 0xf)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_ST_INFO(bind, type)(((bind)&lt;&lt;4) + ((type)&amp;0xf))</span></span><br></pre></td></tr></table></figure><blockquote><p>  st_name：该符号的名称，指向.strtab section某个索引位置。</p><p>  st_info：说明该符号的类型和绑定属性（binding attributes）。</p><p>  st_other：说明该符号的可见性（Visibility）。它往往和st_info配合使用，用法见上图所示的三个宏。</p><p>  st_shndx：symbol table中每一项元素都和其他section有关系。st_shndx就是这个相关section的索引号</p><p>  st_value：符号的值，不同类型的ELF文件该变量的含义不同。比如：对于relocatable类型，st_value：表示该符号位于相关section（索引号为st_shndx）的具体位置。而对于shared和executable类型，st_value为该符号的虚拟内存地址。</p><p>  st_size：和这个符号关联的数据的长度</p></blockquote><h1 id="5-SO文件的操作手撕姿势"><a href="#5-SO文件的操作手撕姿势" class="headerlink" title="5. SO文件的操作手撕姿势"></a>5. SO文件的操作手撕姿势</h1><p>找到Symbol Table符号表，然后对其中的符号的入口地址进行查询</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在仔细研究上述流程后，我目前的设想如下：</p><p>与在张同学修改<code>GOT</code>的基础上，拓展支持从<code>PLASH</code>中加载SO的模式：</p><p>首先加载完整的动态链接库进入内存中。</p><p>1）延迟加载的动态绑定技术。在加载可执行文件的时候，直接替换<code>GOT</code>中的<code>GOT[2]</code>表项，重定位到自己的解析函数，然后进一步对<code>GOT</code>进行操作，将内存中的动态库的对应函数入口写入GOT。</p><p>2）加载时绑定。在加载可执行文件的时候，通过遍历可执行文件的<code>rela.dyn</code>表项，将对应的，在内存中存在的动态链接库的函数入口填入<code>GOT</code>表格中。</p><p>思路二的优势：</p><p>1）能减小ArceOS本身的大小，不需要涵盖so库。在不需要动态链接的时候可以不加载SO库，而需要的时候可以去加载。不用像是思路一一样需要重新构建ArceOS本身才能完成两个状态的切换。</p><p>2）有利于快速开发，拓展库支持。只需要替换原有库的一些底层组件，就可以大概率实现正确，而不需要像思路一一样还要再搞一遍库的支持。</p><p>思路二的劣势：</p><p>1）需要花费额外的时间加载so库，相比思路一要慢一些。但是考虑到Unikernel的特性，我怀疑这个不是一个劣势。</p><p>2）在发布ArceOS的时候，需要将修改的so库与对应的组件一同发布，比直接思路一可以直接发布一个组件要麻烦很多。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;0-问题的提出与笔者的目标&quot;&gt;&lt;a href=&quot;#0-问题的提出与笔者的目标&quot; class=&quot;headerlink&quot; title=&quot;0. 问题的提出与笔者的目标&quot;&gt;&lt;/a&gt;0. 问题的提出与笔者的目标&lt;/h1&gt;&lt;p&gt;石老师对于为ArceO</summary>
      
    
    
    
    
    <category term="ArceOS开发日记" scheme="https://inchinaxiaofeng.github.io/tags/ArceOS%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
    <category term="Linux" scheme="https://inchinaxiaofeng.github.io/tags/Linux/"/>
    
    <category term="动态加载" scheme="https://inchinaxiaofeng.github.io/tags/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
    <category term="ELF" scheme="https://inchinaxiaofeng.github.io/tags/ELF/"/>
    
  </entry>
  
</feed>

[{"title":"ArceOS的mocklibc_libloader开发的线程问题与思考","url":"/2025/01/24/ArceOS的mocklibc-libloader开发的线程问题与思考/"},{"title":"ArceOS的mocklibc开发手记","url":"/2025/01/18/ArceOS的mocklibc开发手记/","content":"\n\n\n[TOC]\n\n\n\n# 0. 这个文件的必要性和阅读的注意事项\n\n因为自己在实现musl兼容库——mocklibc的时候，往往要进行一些分析，也要写一些东西。这些东西往往不成体系，也没有什么总结的价值，基本是随写随丢的状态。但是这个随写随丢有时候反而会造成一些困扰，特别是在回顾之前思路的时候。同时，写下这个博客也算是记录自己的工作内容\n\n所以，我开了这个文件，用来记录自己的笔记。作为阅听者的你，**除非有特别的需求，否则建议退出**，因为这里的内容可能是**错误的，有偏差的，毫无格式的，语言不通顺的，可能会给你带来误导，特别当你对相关问题不熟悉的情况下！！！**\n\n阅读方式：基本没有什么固定的格式，一个建议的格式如下：\n\n*   发生一个事件、实现、修复或思考的时候，将其记录在三级标题中\n*   在每一个三级标题下有一个四级标题，用于记录创建时间与最后修改时间\n\n# 1. mocklibc开发手记\n\n### [ADD] sleep函数\n\n#### 创建：2025_1_18_21:53；修改：2025_1_18_22:09\n\n需要实现的：`sleep()`，依赖于：`nanosleep()`，`nanosleep`依赖于`syscall_ret`和`__clock_nanosleep()`\n\n`syscall_ret`本身不难实现，注意的是要写入一个叫做`errno`的全局变量中\n\n`__clock_nanosleep`或许可以作为替换的选择\n\n`__clock_nanosleep`函数依赖`__syscall_cp`函数，以及`IS32BIT`宏（定义在好多地方）\n\n`src/thread/__syscall_cp.c` 在中，通过 `week_alias` 告诉我们当 single thread 的时候 `syscall_cp` 可以退化为普通的 syscall 的。\n\n不行的话，我就替换`__clock_nanosleep`\n\n有一说一可以直接用sleep，ArceOS底层有这个函数[X]，就用这个\n\n完成支持。\n\n### [FIXME] BUG 实现pthread\n\n#### 创建19号上午\n\n很奇怪，在不同情况下会跑飞之类的，但是也就这样了吧，先放下，解决另一个\n\n### [XXX] BUG Math库中，所有带l（long）类型的操作都会被导向到一些奇怪的符号，例如__getf2\n\n#### 创建19号中午\n\n可能的相关文章：https://github.com/ziglang/zig/issues/5320\n\n`-fno-compiler-rt`是什么？\n\n有关运行时库的内容：https://compiler-rt.llvm.org/\n\n这个是CSDN上的运行时库的介绍：https://blog.csdn.net/ssdlearnerused/article/details/107426495\n\n这个是一个类似问题，有解决的：https://rustcc.cn/article?id=50ac4eec-17eb-4fc7-be08-a23d7794fefc\n\n最接近和具有参考价值的：https://github.com/termux/termux-packages/issues/8029\n\n![image-20250119162526756](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250119162526756.png)\n\n![image-20250119162546755](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250119162546755.png)\n\n![image-20250119162657635](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250119162657635.png)\n\n>   Yeah, that's the problem: libtool supplying all the link flags to the compiler and overriding the runtime library the compiler chooses with `-nostdlib`. Maybe it needs to be patched to add `compiler-rt` instead of `libgcc`, but in the meantime, perhaps we could override it by passing in [the `-rtlib=compiler-rt` flag for those packages, as I did with the Swift CMake config](https://github.com/termux/termux-packages/blob/master/packages/swift/swift-ndk-23.patch#L187).\n>   是的，这就是问题所在： libtool 向编译器提供所有链接标志，并使用 `-nostdlib` 覆盖编译器选择的运行时库。也许需要修补以添加 `compiler-rt` 而不是 `libgcc`，但与此同时，也许我们可以通过为[这些包传递 `-rtlib=compiler-rt` 标志来覆盖它，就像我对 Swift CMake 配置所做的那样](https://github.com/termux/termux-packages/blob/master/packages/swift/swift-ndk-23.patch#L187)。\n\ngcc关于这个问题的通信邮件：\n\nhttps://gcc.gnu.org/legacy-ml/gcc/2001-09/msg00262.html\n\nhttps://gcc.gnu.org/legacy-ml/gcc/2001-09/msg00327.html\n\n##### 第一次修改方式\n\n添加链接：`$($CC -print-libgcc-file-name)`\n\n##### 第一次修改前报错：\n\n```\nmake -C hello dynamic\nmake[1]: 进入目录“/home/marinatoo/Dev/arceos/mockc_apps/hello”\nriscv64-linux-musl-gcc -nostdlib -nodefaultlibs -ffreestanding -O0 -mcmodel=medany -nostartfiles -I../../ulib/mocklibc_lib/include -c hello.c  -o hello.o \nriscv64-linux-musl-ld hello.o  -L../../ulib/mocklibc_lib/lib -lmock    -o hello\nriscv64-linux-musl-ld: warning: cannot find entry symbol _start; defaulting to 0000000000010500\nriscv64-linux-musl-ld: ../../ulib/mocklibc_lib/lib/libmock.so: undefined reference to `__getf2'\nriscv64-linux-musl-ld: ../../ulib/mocklibc_lib/lib/libmock.so: undefined reference to `__eqtf2'\nriscv64-linux-musl-ld: ../../ulib/mocklibc_lib/lib/libmock.so: undefined reference to `__addtf3'\nriscv64-linux-musl-ld: ../../ulib/mocklibc_lib/lib/libmock.so: undefined reference to `__floatsitf'\nriscv64-linux-musl-ld: ../../ulib/mocklibc_lib/lib/libmock.so: undefined reference to `__divtf3'\nriscv64-linux-musl-ld: ../../ulib/mocklibc_lib/lib/libmock.so: undefined reference to `__letf2'\nriscv64-linux-musl-ld: ../../ulib/mocklibc_lib/lib/libmock.so: undefined reference to `__fixtfdi'\nriscv64-linux-musl-ld: ../../ulib/mocklibc_lib/lib/libmock.so: undefined reference to `__fixtfsi'\nriscv64-linux-musl-ld: ../../ulib/mocklibc_lib/lib/libmock.so: undefined reference to `__lttf2'\nriscv64-linux-musl-ld: ../../ulib/mocklibc_lib/lib/libmock.so: undefined reference to `__netf2'\nriscv64-linux-musl-ld: ../../ulib/mocklibc_lib/lib/libmock.so: undefined reference to `__extenddftf2'\nriscv64-linux-musl-ld: ../../ulib/mocklibc_lib/lib/libmock.so: undefined reference to `__extendsftf2'\nriscv64-linux-musl-ld: ../../ulib/mocklibc_lib/lib/libmock.so: undefined reference to `__multf3'\nriscv64-linux-musl-ld: ../../ulib/mocklibc_lib/lib/libmock.so: undefined reference to `__gttf2'\nriscv64-linux-musl-ld: ../../ulib/mocklibc_lib/lib/libmock.so: undefined reference to `__subtf3'\nriscv64-linux-musl-ld: ../../ulib/mocklibc_lib/lib/libmock.so: undefined reference to `__trunctfsf2'\nriscv64-linux-musl-ld: ../../ulib/mocklibc_lib/lib/libmock.so: undefined reference to `__trunctfdf2'\nmake[1]: *** [Makefile:37：dynamic] 错误 1\nmake[1]: 离开目录“/home/marinatoo/Dev/arceos/mockc_apps/hello”\nmake: *** [Makefile:8：subdir] 错误 2\n```\n\n##### 第一次修改后报错：\n\n```\nmake -C hello dynamic\nmake[1]: 进入目录“/home/marinatoo/Dev/arceos/mockc_apps/hello”\nriscv64-linux-musl-gcc -nostdlib -nodefaultlibs -ffreestanding -O0 -mcmodel=medany -nostartfiles -I../../ulib/mocklibc_lib/include -c hello.c  -o hello.o \nriscv64-linux-musl-ld hello.o  -L../../ulib/mocklibc_lib/lib -lmock   /home/marinatoo/App/riscv64-linux-musl-cross/bin/../lib/gcc/riscv64-linux-musl/11.2.1/libgcc.a -o hello\nriscv64-linux-musl-ld: warning: cannot find entry symbol _start; defaulting to 0000000000010500\nriscv64-linux-musl-ld: hello: hidden symbol `__getf2' in /home/marinatoo/App/riscv64-linux-musl-cross/bin/../lib/gcc/riscv64-linux-musl/11.2.1/libgcc.a(getf2.o) is referenced by DSO\nriscv64-linux-musl-ld: final link failed: bad value\nmake[1]: *** [Makefile:37：dynamic] 错误 1\nmake[1]: 离开目录“/home/marinatoo/Dev/arceos/mockc_apps/hello”\nmake: *** [Makefile:8：subdir] 错误 2\n```\n\n可能原因：https://stackoverflow.com/questions/23696585/what-does-exactly-the-warning-mean-about-hidden-symbol-being-referenced-by-dso\n\n问题并未得到解决，这里我想应该是将上述符号切换为DEFAULT（HIDDEN），而不是让他们保持NOTYPE.\n\n这是另一个相关的：https://gcc.gnu.org/bugzilla/show_bug.cgi?format=multiple&id=36669\n\n#### 该问题的完整描述：\n\n我的问题是这样的：我使用的是musl的编译器（版本不重要），其在面临`float_128`类型变量的时候，出于某些我目前不能肯定的原因（我有看到说musl不支持这个长度），会尝试链接外部的函数，例如：`__getf2`这样的。\n但是相关函数musl库本身并没有实现，那么我使用musl编译库的时候就会出现，由于我是要开发自己的库，使用了`-nostdlib`，所以屏蔽了标准库，然后我想说要不就先链接已有的这些外部函数。路径如下：`/home/marinatoo/App/riscv64-linux-musl-cross/bin/../lib/gcc/riscv64-linux-musl/11.2.1/libgcc.a(getf2.o)`，然后链接后出现的问题是：\n`musl`提供的`gcc`库里相关的符号是`hidden`的。然后我尝试链接会报错：`riscv64-linux-musl-ld: hello: hidden symbol __getf2' in /home/marinatoo/App/riscv64-linux-musl-cross/bin/../lib/gcc/riscv64-linux-musl/11.2.1/libgcc.a(getf2.o) is referenced by DSO`。不链接的话就是`riscv64-linux-musl-ld: ../../ulib/mocklibc_lib/lib/libmock.so: undefined reference to __getf2'`\n\n不过这个在遇到float 128类型的时候调用llvm的compile_rt的行为是编译器进行的，所以其实有一个解决方案，就是将它需要的函数自己实现出来，不过考虑到其工作之多，我选择去部分使用llvm的那个实现，不过llvm最终就是用的我上面的那个gcc的实现，我也不确定是不是musl编译器自己的行为。\n但是我出问题的函数是个纯数学库，然后编译后的目标文件中引用了符号\"__getf2\"，然后在这里是没有调用这个函数的，就是，这个是一个0函数调用库，它使用了一些宏定义（如 RPOLY 和 VPOLY）来计算多项式，但这些宏只是用来计算值，并不涉及对其他函数的调用。\n\n然后我的编译选项如下：`CFLAGS = -nostartfiles -ffreestanding -nostdlib -O0 -mcmodel=medany $(INTERNAL_INCLUDE) -fPIC`\n\n`$(SHARED_LIB): $(LIBOBJS) $(CRTOBJS) $(CC) $(CFLAGS) $(LDFLAGS) -shared -fPIC -o $@ $^`\n\n`LINK_FLAGS += /home/marinatoo/App/riscv64-linux-musl-cross/bin/../lib/gcc/riscv64-linux-musl/11.2.1/libgcc.a # 尝试修正compile-rt被-nolib屏蔽的问题，也就是__getf2符号没有的问题。`\n\n这个LINK_FLAGS就是在尝试手动链接这些缺失的库的，不过可以不加\n\n==最终我还是选择自己去实现这些函数，然后直接链接了，然后在这里函数中跳转到一个“未实现”的系统调用，然后直接退出==\n\n### 思考：是否可以找到足够底层且开放的输出接口，去完成musl中的输出底层接口的替换\n\n#### 创建：1_20_9:06\n\n可能是`axhal::console::write_bytes(s.as_bytes());`，不带`fmt`，能直接输出，似乎可以作为musl中`print_core`函数的输出接口。往下再探索，发现其实就已经是跟具体的架构相关的代码了，感觉不是很适合继续挖掘。\n\n现在的问题是，我打算直接使用printf_core来验证思路，但是printf_core在使用errno，而errno是需要通过`__errno_location()`的返回值来获取的，`__errno_location()`依赖`__pthread_self()`来获得，同时也依赖其返回的结构体指针，然后我要定位这个函数的位置。\n\n`#define __pthread_self() ((pthread_t)__get_tp())`，依赖`__get_tip()`。这个与架构相关，RV64的：`nvim arch/riscv64/pthread_arch.h`\n\n```asm\nstatic inline uintptr_t __get_tp()\n{\n\tuintptr_t tp;\n\t__asm__ __volatile__(\"mv %0, tp\" : \"=r\"(tp));\n\treturn tp;\n}\n\n#define TLS_ABOVE_TP\n#define GAP_ABOVE_TP 0\n\n#define DTP_OFFSET 0x800\n\n#define MC_PC __gregs[0]\n```\n\n我在想，这样的汇编其实什么都没做，不会影响执行流（对于RV64），那么是否可以直接用？\n\n==**我发现printf函数在面对FILE的问题的时候，需要大幅修改原来函数，会使得思路二的优势丧失，不建议使用了**==\n\n==**在没有系统解决FILE的兼容之前，不能盲目替换。因此暂时放弃相关想法**==\n\n### 开发`errno`以及`__errno_location()`函数\n\n#### 创建：2025_1_20 13:16\n\n直接复制的，用的就是上面的思路，直接使用，经过测试是报错了。\n\n在理论上而言，tp应当指向一个结构体，映射关系就在这个结构体中，说明当前的硬件线程编号，以及已经分配的地址空间。但是我发现报错了，报的LoadFault。但是tp看不太出来问题：\n\n```bash\nUnhandled trap Exception(LoadFault) @ 0xffffffc080110670:\nTrapFrame {\n    regs: GeneralRegisters {\n        ra: 0xffffffc08011066e,\n        sp: 0xffffffc080266620,\n        gp: 0xffffffc08026aff0,\n        tp: 0xffffffc080266520,\n        t0: 0xffffffc08021b8c8,\n        t1: 0xffffffc0801104ec,\n        t2: 0xf0,\n        s0: 0xffffffc080266670,\n        s1: 0x1,\n        a0: 0x80047f5c,\n        a1: 0x4,\n        a2: 0x0,\n        a3: 0x4,\n        a4: 0x4000000000,\n        a5: 0x80047f5c,\n        a6: 0x0,\n        a7: 0x4442434e,\n        s2: 0x2,\n        s3: 0xffffffc0802668b8,\n        s4: 0xffffffc080266958,\n        s5: 0xffffffc0802668f8,\n        s6: 0xffffffc08032f766,\n        s7: 0x11300000001,\n        s8: 0xffffffc08026aff0,\n        s9: 0x18,\n        s10: 0x9,\n        s11: 0x4,\n        t3: 0xffffffc08032f746,\n        t4: 0xffffffffffffffbf,\n        t5: 0x1,\n        t6: 0xffffffffffffff8f,\n    },\n    sepc: 0xffffffc080110670,\n    sstatus: 0x8000000200006100,\n}\n```\n\n![image-20250120140704716](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250120140704716.png)\n\n总体而言是这样的，所以是出现了一些问题，本来应该去访问高地址的\n\n![image-20250120152822543](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250120152822543.png)\n\n所以是`tp`寄存器本身的问题，这里会出现问题，也就是tp寄存器存在问题。tp寄存器存放的数值很奇怪，或者说，是否意味着，这个值本来就是在低地址呢？\n\n==**保留BUG**==\n\n### 我觉得得做文件系统的迁移了\n\n#### 创建：1_20 16:20\n\n思路，先通过对文件系统操作的迁移，理解ArceOS的文件系统与Linux的文件系统的最基础共同点，然后以此为基础，进行对Linux文件系统的模拟\n\n然后文件系统的迁移要优先考虑一些宏观操作的相同。\n\n重点是能不能找到一些同级抽象的东西，或者说比目标兼容库更底层的操作，并以这些操作为基础组合模拟目标兼容库的底层操作。\n\n做了一些\n\n### [FIXED] BUG修复：动态链接编译的时候，尤其是开了没有startfile的那个选项后，entry可能不是main函数\n\n在load.rs中修复：\n\n![image-20250121111255172](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250121111255172.png)\n\n修改后：\n\n![image-20250121115923606](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250121115923606.png)\n\n### [FIXED] BUG修复：lgamma_r.c文件中的函数在编译后会出现bgu指令，对a5寄存器的空间写，但是a5已经成0了，目前看不出有什么特别的点\n\n#### 创建时间：1_21 20：29\n\n![image-20250121202922883](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250121202922883.png)\n\n![image-20250121203003271](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250121203003271.png)\n\n很神奇\n\n出于对sw命令的定位，我做了如下操作：![image-20250121203350630](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250121203350630.png)\n\n![image-20250121203336409](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250121203336409.png)\n\n所以，问题定位完成。\n\n问题是，这个东西理论上是有的哇：\n![image-20250121203808277](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250121203808277.png)\n\n![image-20250121203822400](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250121203822400.png)\n\n可能是因为是全局变量的原因，没有被正确的指定！\n\n![image-20250121204100305](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250121204100305.png)\n\n![image-20250121204335172](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250121204335172.png)\n\n所以我们可以知道，要在modify的时候，为这些全局变量做modify。\n\n![image-20250121205251093](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250121205251093.png)\n\n这个符号我好像早就注意到了，但是一直没有理会，没想到真的出问题了。\n\n一个很值得思考的是，函数是txt，所以位置是固定的，也不用考虑那么多，但是全局变量是什么东西？这个放在哪里？\n\n最后修复方案：![image-20250121213221303](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250121213221303.png)\n\n### 阅读计划：https://blog.csdn.net/tjcwt2011/article/details/106520862\n\n### [FIXED] 超长期的一个BUG\n\n#### 创建：1_21 20:44 修改： 1_24 11:32\n\n我发现，似乎在某些情况下，qemu在启动-l debug选项的时候就会发生：qemu卡死在一个tlb重填的位置，然后一直卡着，关闭掉qemu之后，反而在qemu.log上一直在写入，但是在文件系统中找不到文件，可是硬盘很快就会占满！具体描述后面我会插视频！\n\n然而这个bug感觉似乎不是随时都可以的，而是在特殊的一段时间内，会频繁的发生，现在就可以，我有一个猜想：==可能是内存剩余空间少的时候，就会发生问题！==\n\n\n\n==已经修正==\n\n这个BUG的修正似乎与下面这个有一定的关系，当我修正[这个问题](#[FIXED] 关于在部分情况下使用debug参数和其他参数结果不一致的问题)后，这个超长期BUG就自己消失了。\n\n### [FIXED] 关于在部分情况下使用debug参数和其他参数结果不一致的问题\n\n#### 创建：2025_1_22，修改：2025_1_24 11:30\n\n在过去一段时间内，在杨金全同学的帮助下，我发现了在libloader_lib应用中src/main.rs下汇编代码的一处错误，在修正这个错误后，似乎在执行QEMU模拟的时候不会再发生启用debug log参数和启用info log参数在结果上有不同的bug了。\n\n具体如下：\n\n![image-20250124113039792](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250124113039792.png)\n\n修改后：\n\n![image-20250124113059508](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250124113059508.png)\n\n由于写下这个记录距离修正BUG已经过了两天，所以记录不是很详细\n\n推测是由于写入的错误，损坏了一些关键信息，而这些信息在启用debug参数后是会被关键依赖，导致控制流程跑飞。具体跑飞包括LoadFault、StoreFault、TLB反复重填写等等。在启用qemulog记录的情况下，还会出现卡死、无法退出模拟，==并且在强行关闭后依然发生着向qemulog持续不停的写入新记录的情况，只能重启解决。这个问题我觉得很有意思，而且应该会导向qemu的一个关键bug。目前qemu的版本为9.1.2，系统是Ubuntu22.04 LTS。目前暂时不准备解决。我捕捉到一次发生的卡死是卡在了TLB重填写的部分，在访问一个地址的时候发生TLB缺失，重填后依然缺失，如此循环。==\n\n![image-20250124114220469](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250124114220469.png)\n\n这个是一个截图的一部分，但是也完整涵盖了整个循环流程，因为截图中有隐私信息，就不全部展示了。\n\n### [Bug reserved.]关于Qemu中可能存在的BUG的讨论\n\n#### 创建：2025-1-24 11:44\n\n[上述BUG](#[FIXED] 关于在部分情况下使用debug参数和其他参数结果不一致的问题)修正前会出现：\n\n推测是由于写入的错误，损坏了一些关键信息，而这些信息在启用debug参数后是会被关键依赖，导致控制流程跑飞。具体跑飞包括LoadFault、StoreFault、TLB反复重填写等等。在启用qemulog记录的情况下，还会出现卡死、无法退出模拟，==并且在强行关闭后依然发生着向qemulog持续不停的写入新记录的情况，只能重启解决。这个问题我觉得很有意思，而且应该会导向qemu的一个关键bug。目前qemu的版本为9.1.2，系统是Ubuntu22.04 LTS。目前暂时不准备解决。我捕捉到一次发生的卡死是卡在了TLB重填写的部分，在访问一个地址的时候发生TLB缺失，重填后依然缺失，如此循环。==\n\n![image-20250124114220469](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250124114220469.png)\n\n这个是一个截图的一部分，但是也完整涵盖了整个循环流程，因为截图中有隐私信息，就不全部展示了。\n\nQEMU可能存在的BUG点是：在运行的时候卡死，就不能正常退出，而且退出后依然在向log书写，即使删除qemu.log，还是会继续书写，直到将空间占满卡崩Ubuntu。\n\nBUG可以通过以下方式复现，感兴趣的可以去查看：\n\n访问[BUG所在的仓库分支](https://github.com/inchinaxiaofeng/arceos/tree/mocklibc_libloader)，BUG存在于[这一条提交记录](https://github.com/inchinaxiaofeng/arceos/commit/1c38b664e5b59932b4ee07be8bdd88935390db57)中。clone之后，在arceos（也就是下载下的那个目录）中切换到对应的mocklibc_libloader分支下的提交记录：Commit 1c38b66，然后在arceos目录下运行命令`./loader_lib.sh -l debug`，就可以观察到。\n\n再次声明我的环境：\n\n```bash\nqemu --version\nqemu-io version 9.1.2\nCopyright (c) 2003-2024 Fabrice Bellard and the QEMU Project developers\n\ncargo --version\nwarning: `/home/marinatoo/.cargo/config` is deprecated in favor of `config.toml`\nnote: if you need to support cargo 1.38 or earlier, you can symlink `config` to `config.toml`\ncargo 1.85.0-nightly (652623b77 2024-12-20)\n\nneofetch\n            .-/+oossssoo+/-.               marinatoo@marinatoo-ASUS-TUF \n        `:+ssssssssssssssssss+:`           ---------------------------- \n      -+ssssssssssssssssssyyssss+-         OS: Ubuntu 22.04.4 LTS x86_64 \n    .ossssssssssssssssssdMMMNysssso.       Host: ASUS TUF Gaming F15 FX507ZM_FX507ZM 1.0 \n   /ssssssssssshdmmNNmmyNMMMMhssssss/      Kernel: 6.8.0-51-generic \n  +ssssssssshmydMMMMMMMNddddyssssssss+     Uptime: 1 hour, 46 mins \n /sssssssshNMMMyhhyyyyhmNMMMNhssssssss/    Packages: 2675 (dpkg), 21 (snap) \n.ssssssssdMMMNhsssssssssshNMMMdssssssss.   Shell: bash 5.1.16 \n+sssshhhyNMMNyssssssssssssyNMMMysssssss+   Resolution: 4096x2304 \nossyNMMMNyMMhsssssssssssssshmmmhssssssso   DE: GNOME 42.9 \nossyNMMMNyMMhsssssssssssssshmmmhssssssso   WM: Mutter \n+sssshhhyNMMNyssssssssssssyNMMMysssssss+   WM Theme: Adwaita \n.ssssssssdMMMNhsssssssssshNMMMdssssssss.   Theme: Yaru [GTK2/3] \n /sssssssshNMMMyhhyyyyhdNMMMNhssssssss/    Icons: Yaru [GTK2/3] \n  +sssssssssdmydMMMMMMMMddddyssssssss+     Terminal: WarpTerminal \n   /ssssssssssshdmNNNNmyNMMMMhssssss/      CPU: 12th Gen Intel i7-12700H (20) @ 2.300GHz \n    .ossssssssssssssssssdMMMNysssso.       GPU: Intel Alder Lake-P \n      -+sssssssssssssssssyyyssss+-         GPU: NVIDIA GeForce RTX 3060 Mobile / Max-Q \n        `:+ssssssssssssssssss+:`           Memory: 10288MiB / 15608MiB \n            .-/+oossssoo+/-.\n                                                                   \n                                                                   \n```\n\n\n\n### [FIXED] 在关于ArceOS mocklibc_libloader中线程创建的BUG修复[见专题文章]\n\n#### 创建2025_1_24 11：30\n\n","tags":["ArceOS开发日记","mocklibc开发手记"]},{"title":"ArceOS加载Linux应用的思路","url":"/2025/01/13/ArceOS加载Linux应用的思路/","content":"\n[TOC]\n\n# 0. 问题的出现\n\n因为在ArceOS开发组实习中，我经手的项目是令ArceOS支持原生Linux应用，所以我对这些问题比较熟悉，在此写一篇文章来介绍这个过程。\n\n# 1. ArceOS的不同\n\nArceOS是一个Unikernel的操作系统，具体什么是Unikernel我不做过多阐释，仅仅列举与本问题相关的、与常规的Monokernel（Monolithic kernel）的几个不同：\n\n*   Unikernel是没有内核态与用户态的区分，所有代码都运行在内核态中。\n*   用户的代码和内核代码会被打包成一个可执行文件。\n*   Monokernel中的“系统调用”在Unikernel中是以“函数调用”的形态体现的，这个往往也是其运行高效的一个原因。\n*   Unikernel是没有Process（进程）的概念的，或者说它有且仅有一个Process。\n*   Unikernel是可以有多个Thread的。\n\n笔者写下这个博客时，ArceOS的进度是希望直接加载动态链接的Linux应用，完成对Linux应用的支持，可以在不修改、不重新编译的情况下直接执行原生Linux应用。因此，石磊老师提出了两种思路。\n\n# 2. 两种思路\n\n![49f3055a02621dea4523bb6eec597afa](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/49f3055a02621dea4523bb6eec597afa.jpg)\n\n第一种思路是通过在ArceOS内部创建中间层进行适配，第二种就是通过对动态库进行改造，对底层函数进行替换完成开发。\n\n第一种shi x na\n\n*   第一种方式：通过在ArceOS内部创建中间层进行适配\n    *   这意味着绝大多数的代码将在ArceOS内部进行开发，通常意味着需要在这个中间层中实现所有的musl兼容库的代码开发。\n    *   这个不仅意味着ArceOS本身将会变得很大，不能实现库代码与系统代码的分离，同时也意味着我们在拓展更多版本的支持的时候需要直接修改代码本身。\n    *   优势就是我们不需要从PLASH中同时加载Lib和App，其加载的速度要快一些。\n*   第二种思路：通过对musl库的考察，最小化替换其中仅能用于Linux而不是ArceOS的代码\n    *   这个能够加速开发过程，并且简化测试过程，因为绝大多数代码都是使用的musl库的代码，仅仅xu yao dui\n\n# 3. 思路二的支持现状和加载过程详解\n\n## 3.1. 完整支持的头文件\n\n-   [x] endian.h\n-   [x] stdbool.h\n-   [x] stdint.h\n-   [ ] features.h(融合了src/include/features.h)\n-   [x] ctype.h\n-   [x] float.h\n-   [x] limits.h\n-   [x] stdarg.h\n-   [x] stdbool.h\n-   [ ] stdlib.h\n-   [ ] time.h\n-   [x] math.h\n-   [ ] string.h\n-   [x] values.h\n-   [x] stdc_predef.h\n\n## 3.2. 注意的问题\n\n目前在某些函数部分使用了特殊的一个调用，在使用到不支持函数的时候会输出`Not implement yet.`并退出。这部分均是使用到`float 128`类型的。使用这个类型的时候，musl会去调用一个`compile_rt`库，并链接这里的函数。但是由于我使用`-nostdlib`参数去编译库，所以这部分的库不会被链接进去，我自己将这些函数实现了，具体的实现就是在内部调用一个NOIMPL并退出，作为占位符。\n\n## 3.3. 加载过程详解","tags":["ArceOS开发日记","动态加载","ELF","符号表"]},{"title":"Linux动态加载过程详解与手撕SO文件","url":"/2025/01/12/手撕SO文件/","content":"\n[TOC]\n\n\n\n# 0. 问题的提出与笔者的目标\n\n石老师对于为ArceOS适配Linux ELF文件动态链接提出了两个不同思路：\n![49f3055a02621dea4523bb6eec597afa](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/49f3055a02621dea4523bb6eec597afa.jpg)\n\n在为ArceOS实现动态加载的时候，同组张明洋同学贡献了这样的思路：\n通过访问`.rela.plt`实现链接时重定位，通过在`.rela.plt`中得到需要重定位的函数条目，然后在自行用Rust实现的兼容musl库中寻找目标函数条目，通过访问`r_offset`，搜寻对应地址的解析函数GOT的表项地址，将Rust兼容库对应函数的地址（Rust中的）填入GOT的对应表项目中。属于上图中的第一种思路。\n\n我希望通过这篇文章的总结，能够对整个Linux的动态加载机制与SO文件的组成有足够的了解，深入分析第一种实现方式，探索第二种实现方式的可能性。\n\n我的期望是，通过最小化修改musl库（即尽可能通过复制的方式），通过传递abi table的方式，对musl库中的关键节点进行替换，在不需要实现一个Rust版的兼容musl的C库的情况下，在加载原始Linux应用的同时，向内存中加载替换版so库，并且通过修改`GOT`的方式，以及修改`PLT`函数的方式，扩展支持到延迟加载动态库中函数的地步。\n\n# 1. 静态链接与动态链接概念的简单区分\n\n静态链接是将所有第三方库函数全部打包到了一个可执行文件中，其体积较大，加载简单，其使用的库常用名称是`*.a`，是通过`ar`构建的；\n动态链接不链接库文件，而是在运行时去加载，体积小，实现复杂，其使用的库常用名称为`*.so`，通过`gcc`类编译器构建的。\n\n我们把编译后但是还未链接的二进制机器码文件称为目标文件（Object File），那些第三方库是其他人编译打包好的目标文件，这些库里面包含了一些函数，我们可以直接调用而不用自己动手写一遍。在编译构建自己的可执行文件时，使用静态链接的方式，其实就是将所需的静态库与目标文件打包到一起。最终的可执行文件除了有自己的程序外，还包含了这些第三方的静态库，可执行文件比较臃肿。\n\n动态链接不将所有的第三方库都打包到最终的可执行文件上，而是只记录用到了哪些动态链接库，在运行时才将那些第三方库装载（Load）进来。装载是指将磁盘上的程序和数据加载到内存上。\n\n> 注意的是，不同操作系统的动态链接库格式不同，linux的是共享目标文件（Shared Object）`.so`，windows的是动态链接库（Dynamic Link Library）`.dll`\n\n# 2. 位置无关码PIC的原理、动态链接库、代码重定位\n\n问题：动态链接库在编译时并未确定其在内存中的具体位置，而是在运行时加载，因此必须进行加载时重定位。\n\nNOTE!: 本节参考文章：<https://blog.csdn.net/tilblackout/article/details/135585340>\n\n## 1. 位置无关的编译器选项\n\n这四个编译选项与位置无关代码(Position Independent Code，PIC)和位置无关可执行文件(Position Independent Executable，PIE)有关。它们的作用主要是为了提高代码的可重定位性，使得代码更适用于共享库和在内存中的不同位置加载的情况：\n\n1. `-fPIC(Position Independent Code)`\n    * **作用：**生成位置无关代码，适用于共享库。\n    * **用途：**当编译共享库时，通常需要使用`-fPIC`，以确保库中代码可以在内存中的不同位置加载。\n2. `-fPIE(Position Independent Executable)`\n    * **作用：** 生成位置无关的可执行文件，适用于可执行文件。\n    * **用途：** 当编译可执行文件时，使用`-fPIE`会生成一个可以在内存中的不同位置加载的可执行文件。\n3. `-pie(Position Independent Executable)`\n    * **作用：** 生成位置无关的可执行文件，与`-fPIE`类似。\n    * **用途：** 在链接阶段，使用`-pie`可以生成位置无关的可执行文件，这也是为了提高安全性。与 `-fPIE` 不同的是，`-pie`在链接时指定，而不是在编译时。\n4. `-fno-pic`\n    * **作用：** 禁用位置无关代码。\n    * **用途：** 当不需要位置无关代码时，使用`-fno-pic`禁用，生成与地址相关的代码。\n\n## 2. 加载动态链接库\n\n### 2.1. 问题引入\n\n构建动态链接库的时候，链接器事先无法知道任何给定共享库将在进程的虚拟内存中的哪个位置加载。这个问题的解决方法视操作系统不同而不同，这里以Linux为例来讲解一个实现的思路。\n\n```c\nint test = 10;\n\nint func(int a)\n{\n    test += a;\n    return test;\n}\n```\n\n上述代码编译成动态链接库后，涉及到用`mov`指令将全局变量`test`的值从内存的位置取到寄存器中。但是`mov`指令需要**绝对地址**，而动态库是没有预定义的加载地址，所以这个地址将在运行时确定。\n\nLinuxELF共享库中，主要有两个解决这个问题的方法：加载时重定位和位置无关代码。\n\n### 2.2. 加载时重定位（Load-time relocation）\n\n* **实时性：** 在加载时进行地址重定位，即在将共享库加载到进程的地址空间时，需要根据实际的加载地址对库中的数据和代码引用进行修正。这就是为什么称之为“加载时”重定位。\n* **非位置无关：** 共享库中的代码和数据引用是使用绝对地址的，因此必须在加载时将这些地址调整为实际的加载地址。\n\n存在的问题：\n\n1. 性能问题\n    当一个应用程序加载与加载时重定位条目关联的共享库时，尽管只需加载重定位的条目，但如果一个复杂的软件在启动时加载多个大型共享库，并且每个库都需要进行加载时重定位，会导致应用程序启动时间明显延迟。\n2. 代码段无法共享\n    共享库的初衷之一是为了节省RAM，使得一些常见的共享库能够被多个应用程序共享。这意味着对于每个应用程序，共享库都必须完全加载到内存中，导致相当大量的RAM浪费。\n3. 要求代码段可写\n    为了允许在加载时动态地修改其中的绝对地址，将其调整为实际的加载地址，加载时重定位要求代码段保持可写状态，这带来了潜在的代码安全风险。\n\n对于加载时重定位这种方法，实际上已经过时了，甚至最新的编译器已经不支持这种方法。PIC是目前常见的解决方案，接下来我们就深入讨论一下位置无关代码。\n\n## 3. 位置无关代码（Position Independent Code）\n\nPIC的原理很简单：在代码中对所有全局数据和函数引用添加一个额外的中间层。通过巧妙地利用链接和加载过程中的结果，使共享库的代码部分实现位置无关。\n\n### 3.1.  代码段和数据段之间的偏移\n\nPIC的一个关键点是利用链接时已知的代码段和数据段之间的偏移。当链接器合并多个目标文件时，它会整合它们的各个部分，形成一个大的代码段。因此，链接器了解各个部分的大小和它们的相对位置。\n\n举例来说，代码段可能直接跟在数据部分后面，这意味着从代码部分中的任意指令到数据段开头的偏移量等于代码部分的大小减去指令距离代码部分开头的偏移量。这两个量都是链接器已知的。\n\n当然，其实在代码段和数据段之间有别的段，或者两个段的位置关系不是如此，都不影响链接器**知晓**它们的位置，并了解到所有段的大小。\n\n### 3.2. 全局偏移表（Global Offset Table）\n\n全局偏移表`GOT`可以帮我们实现位置无关数据寻址。实际上`GOT`就是一个地址表，存储在数据段中。假设代码段中的某个指令想要引用一个变量。**它会引用`GOT`中的一个条目，而不是直接使用绝对地址引用(这将需要进行重定位)。**由于`GOT`位于数据段的一个已知位置，这个引用是**相对的**，并且在链接器中是**已知的**，而`GOT`条目本身将包含变量的**绝对地址**。\n\n通过将变量引用重定向到GOT，我们避免了在代码段中直接使用绝对地址，而是通过GOT中的条目进行引用，从而减少了需要在加载时进行的具体地址修正。但是，我们在数据段中引入了一个新的重定位，因为全局偏移表仍然需要包含变量的绝对地址。那么，这样做的优点有哪些呢？\n\n* 加载时重定位需要对每个变量的引用都进行重定位，而在全局偏移表中，只需要对每个变量进行一次重定位\n* 数据段是可写的，并且在进程之间不共享\n\n实际上这就是解决前面提到的加载时重定位的三个缺点。\n\n ==这里我们需要重点关注的是==：**Linux的动态链接器如何在运行时对全局偏移表进行修改**。我们将通过了解这个内容，获得在ArceOS中直接加载SO文件的必要知识。\n\n### 3.3. 函数的重定位\n\n前面介绍的是全局变量的重定位，对于函数也需要重定位，它有着另一种机制：懒绑定。\n\n当共享库引用某个函数时，函数的真实地址在加载时未知。为了加速这个过程，引入了过程链接表(PLT)。PLT包含对函数进行间接调用的代码，而不是直接包含函数地址。在程序执行时，当函数首次调用时，PLT代码负责将函数的真实地址填充到全局偏移表(GOT)中的相应条目。此后的调用直接通过GOT访问函数地址，避免了每个函数调用时的绑定延迟。这种机制减少了不必要的解析工作，提高了程序执行效率。\n\n==这里我们可以知道==：存在某种方式，能够让我们在ArceOS中进行函数重定位。\n\n## 4. 总结\n\n至此解释了什么是位置无关代码，以及它如何帮助创建具有可共享只读文本段的共享库。位置无关代码(PIC)通过引入全局偏移表(GOT)和过程链接表(PLT)实现，解决了共享库加载时的重定位问题。GOT提供了数据和函数的间接引用，PLT实现了懒绑定，推迟函数地址的解析。当然这也伴随额外的内存加载和寄存器使用成本，但在权衡之下，现代的编译器都更倾向于使用PIC。\n\n# 3. 位置无关代码的核心：`GOT`和`PLT`解析\n\n## 3.1. `GOT`和`PLT`是什么？\n\n*   `PLT`: Procedure Link Table，程序链接表\n*   `GOT`: Global Offset Table，全局偏移表\n\n通过将这两个表互相配合解决外部函数符号地址，解决运行时重定位的问题。这种方法可以让函数在调用时才确定地址，进程的启动时间加快，只需要一次绑定，又叫延迟绑定。\n\n如果调用者使用了共享库的符号，则调用者的数据段会有一个GOT，用于记录共享库符号的地址；如果共享库A作为调用者使用了共享库B的符号，则共享库A的数据段也会有一个GOT。由于编译的时候不能知道共享库的符号地址，所以调用者通过GOT获取共享库的符号地址，运行时链接只需要修改位于数据段的GOT的内容，不需要对调用者的代码段重定位。\n\n共享库有数据段和代码段，数据段是每个应用程序各自有一份，代码段是每个应用程序共享一份。\n\n## 3.2. 示例引入与具体分析\n\n```c\n#include <stdio.h>\n\nvoid print_banner() { printf(\"...\\n\"); }\n\nint main(void) {\n  printf(\"begin\\n\");\n  print_banner();\n  return 0;\n}\n```\n\n上述的代码使用了一个外部的函数printf，这个函数会在一个共享库中存在。经过编译和链接之后，上述代码可执行文件中的`print_banner`函数的汇编指令如下：\n\n```asm\n0000000000001149 <print_banner>:\n    1149:\tf3 0f 1e fa          \tendbr64 \n    114d:\t55                   \tpush   %rbp\n    114e:\t48 89 e5             \tmov    %rsp,%rbp\n    1151:\t48 8d 05 ac 0e 00 00 \tlea    0xeac(%rip),%rax        # 2004 <_IO_stdin_used+0x4>\n    1158:\t48 89 c7             \tmov    %rax,%rdi\n    115b:\te8 f0 fe ff ff       \tcall   1050 <puts@plt>\t\t# **<puts函数的地址>**\n    1160:\t90                   \tnop\n    1161:\t5d                   \tpop    %rbp\n    1162:\tc3                   \tret     \n```\n\n可以看到，`print_banner`调用了`puts`函数（函数内部比较简单，直接被优化成puts了），而`puts`函数位于`glibc`动态库内，所以在编译和链接阶段，链接器无法知道进程运行起来后`puts`函数加载的地址。所以，上述的**<puts函数的地址>**一项是无法填充的，只有进程运行起来，`puts`函数的地址才能确定。\n\n问题来了：**进程运行起来之后，glibc动态库也装载了，puts函数地址亦已确定，上述call指令如何修改（重定位）呢？**\n\n*2.2.节中提到的“加载时重定位”就是通过将**<puts函数的地址>**修改为`puts`函数的真正地址解决的*。如前所说：\n\n-   当进程启动，`libc.so`装载完毕，那么`puts`对应二进制代码所在`.text`的地址也确定了，就是说`puts`函数的地址是明确的，修改`call puts`对应汇编二进制代码，改为`puts`正确的地址即可。但现代操作系统在不做特殊操作情况下，是不允许我们修改代码段的（实际还是可以修改的）。\n    ==不过，既然我们自己在写ArceOS，其实完全可以这么做。==张明阳同学的代码就是直接将对应的函数加载到跳转的地址（原本是@plt的）。\n    更好的，我们可以加一层处理，`call`一个特定的内存地址（相对寻址）中存放的地址——存放了`printf`函数地址。如果这个`puts`地址放到`.data`段，这个段系统规定可读可写，访问这个变量就可以了，如果这些函数很多，对应的变量也很多，就可以看成表了。这也是`GOT`表的概念，`GOT`表就是存这些函数的地址，不过这些编译器帮我们做了。`GOT`表但还有一些问题，后面再说。\n-   就刚才的问题，就算可以直接修改代码且也更改了代码，就会打破操作系统文件共用的原则，做不了所有进程共用一个动态库的原则。\n    ==同样的，鉴于ArceOS的Unikernel的特殊性，其实完全可以这么做==。\n    所以我们要有更巧妙的方法来解决这个问题。如果我们通过`PLT`表，放在代码段，不再改变代码，这块代码能准确指引到正确的`GOT`，第一次时还能修改`GOT`表值，做到这样的效果，好像也能解决问题，实际就是这么做的。\n\n**因此，`printf`函数地址只能回写到数据段，而绝不能回写到代码段上。**\n\n**回写：**是指运行时修改，更专业的称谓应该是**运行时重定位**，与之相对应的还有**链接时重定位**。\n\n*   **运行重定位：**通过运行时解决了地址问题，延迟加载的动态绑定技术。\n\n*   **链接重定位：**编译的链接过程，就完成函数地址替换。\n\n## 3.3. PLT的引入\n\n### 3.3.1. 思路分析\n\n根据前面讨论，运行时重定位是无法修改代码段的，只能将`puts`重定位到数据段。那在编译阶段就已生成好的call指令，怎么感知这个已重定位好的数据段内容呢？\n\n答案是：**链接器生成一段额外的小代码片段，通过这段代码获取puts函数地址，并完成对它的调用**。额外代码如下：\n\n```\n.text\n...\n\n// 调用puts的call指令\ncall puts_stub\n...\n\nputs_stub:\n    mov rax, [puts函数的储存地址] // 获取puts重定位之后的地址\n    jmp rax // 跳过去执行puts函数\n\n.data\n...\nputs函数的储存地址：\n　　这里储存puts函数重定位后的地址\n```\n\n链接阶段发现`puts`定义在动态库时，链接器生成一段小代码`puts_stub`，然后`pputs_stub`地址取代原来的`puts`。因此转化为链接阶段对`puts_stub`做链接重定位，而运行时才对`puts`做运行时重定位。\n\n存放函数地址的数据表，称为全局偏移表`（GOT, Global Offset Table）`，而那个额外代码段表，称为程序链接表`（PLT，Procedure Link Table）`。\n\n`GOT`表即：全局偏移表 ，`Global Offset Table`。当动态链接库中的代码使用`PIC`模式编译出地址无关代码时，在调用方需要生成相应的`.got`段来存储函数的地址。相当于一个函数指针来寻址动态链接库中的函数，这样做的原因：把原本在`.text section`中对一个动态库中函数地址的相对地址调用，转换为从数据段`.got`中的函数指针进行间接调用，这样就可以使主模块中（只是这里举例的场景, 调用者不一定是主模块）的`.text section`的代码中的函数地址不用重定位。\n\n当启用延时加载特性时，我们的函数的间接调用会再加一层间接调用，也就是`.plt`段。此时，调用时：`caller -> targetFun@plt -> targetFun@got.plt -> 目标函数`。而`.plt`段的目的是提供一个特殊代码序列，当没有加载地址时，会在`plt`段顺序执行以触发延时加载。当加载完成后，以后都如上面的链条一样两次跳转后到达真正的函数。当有使用`.plt`段的时候，原来的`.got`不再存储函数的指针。此时会有另外一个类似的段来承担 相应的工作：`.plt.got`。\n\n### 3.3.2. 代码解析\n\n`.text`的`main`函数\n\n```asm\n0000000000001149 <print_banner>:\n    1149:\tf3 0f 1e fa          \tendbr64 \n    114d:\t55                   \tpush   %rbp\n    114e:\t48 89 e5             \tmov    %rsp,%rbp\n    1151:\t48 8d 05 ac 0e 00 00 \tlea    0xeac(%rip),%rax        # 2004 <_IO_stdin_used+0x4>\n    1158:\t48 89 c7             \tmov    %rax,%rdi\n    115b:\te8 f0 fe ff ff       \tcall   1050 <puts@plt>\n    1160:\t90                   \tnop\n    1161:\t5d                   \tpop    %rbp\n    1162:\tc3                   \tret    \n\n0000000000001163 <main>:\n    1163:\tf3 0f 1e fa          \tendbr64 \n    1167:\t55                   \tpush   %rbp\n    1168:\t48 89 e5             \tmov    %rsp,%rbp\n    116b:\t48 8d 05 96 0e 00 00 \tlea    0xe96(%rip),%rax        # 2008 <_IO_stdin_used+0x8>\n    1172:\t48 89 c7             \tmov    %rax,%rdi\n    1175:\te8 d6 fe ff ff       \tcall   1050 <puts@plt>\n    117a:\tb8 00 00 00 00       \tmov    $0x0,%eax\n    117f:\te8 c5 ff ff ff       \tcall   1149 <print_banner>\n    1184:\tb8 00 00 00 00       \tmov    $0x0,%eax\n    1189:\t5d                   \tpop    %rbp\n    118a:\tc3                   \tret \n```\n\n可以看到，跳转到的是`<puts@plt>`，地址为`0150`。分析操作码：`e8 f0 fe ff ff`，**e8，偏移跳转，而ff15是绝对跳转**。\n\n```asm\nDisassembly of section .plt.sec:\n\n0000000000001050 <puts@plt>:\n    1050:\tf3 0f 1e fa          \tendbr64 \n    1054:\tf2 ff 25 75 2f 00 00 \tbnd jmp *0x2f75(%rip)        # 3fd0 <puts@GLIBC_2.2.5>\n    105b:\t0f 1f 44 00 00       \tnopl   0x0(%rax,%rax,1)\n```\n\n在这里，我们看到了跳转到`0x2f75(%rip)`处执行（`endbr64`和`bnd jmp`中的`bnd`都可以认为与此问题无关的），即目标地址是当前 `RIP` 的值加上 `0x2f75`。**问题是，此时的rip是多少呢？**\n\n`plt`函数的反汇编如下：\n\n```asm\nDisassembly of section .plt:\n\n0000000000001020 <.plt>:\n    1020:\tff 35 9a 2f 00 00    \tpush   0x2f9a(%rip)        # 3fc0 <_GLOBAL_OFFSET_TABLE_+0x8>\n    1026:\tf2 ff 25 9b 2f 00 00 \tbnd jmp *0x2f9b(%rip)        # 3fc8 <_GLOBAL_OFFSET_TABLE_+0x10>\n    102d:\t0f 1f 00             \tnopl   (%rax)\n    1030:\tf3 0f 1e fa          \tendbr64 \n    1034:\t68 00 00 00 00       \tpush   $0x0\n    1039:\tf2 e9 e1 ff ff ff    \tbnd jmp 1020 <_init+0x20>\n    103f:\t90                   \tnop\n```\n\n\n\n### 3.3.3. GDB调试PLT流程\n\n```asm\n(gdb) l\n1\t#include <stdio.h>\n2\t\n3\tvoid print_banner() { printf(\"...\\n\"); }\n4\t\n5\tint main(void) {\n6\t  printf(\"begin\\n\");\n7\t  print_banner();\n8\t  return 0;\n9\t}\n(gdb) b 6\nBreakpoint 1 at 0x1151: file plt.c, line 6.\n(gdb) r\nStarting program: /home/marinatoo/tmp/plt \n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\n\nBreakpoint 1, main () at plt.c:6\n6\t  printf(\"begin\\n\");\n(gdb) x /5i $pc\n=> 0x55555555516b <main+8>:\t\n    lea    0xe96(%rip),%rax        # 0x555555556008\n   0x555555555172 <main+15>:\tmov    %rax,%rdi\n   0x555555555175 <main+18>:\tcall   0x555555555050 <puts@plt>\n   0x55555555517a <main+23>:\tmov    $0x0,%eax\n   0x55555555517f <main+28>:\tcall   0x555555555149 <print_banner>\n(gdb) # 执行到call处\n(gdb) x /5i $pc\n=> 0x555555555175 <main+18>:\tcall   0x555555555050 <puts@plt>\n   0x55555555517a <main+23>:\tmov    $0x0,%eax\n   0x55555555517f <main+28>:\tcall   0x555555555149 <print_banner>\n   0x555555555184 <main+33>:\tmov    $0x0,%eax\n   0x555555555189 <main+38>:\tpop    %rbp\n(gdb) si\n0x0000555555555050 in puts@plt ()\n(gdb) x /5i $pc\n=> 0x555555555050 <puts@plt>:\tendbr64 \n   0x555555555054 <puts@plt+4>:\tbnd jmp *0x2f75(%rip)        # 0x555555557fd0 <puts@got.plt>\n   0x55555555505b <puts@plt+11>:\tnopl   0x0(%rax,%rax,1)\n   0x555555555060 <_start>:\tendbr64 \n   0x555555555064 <_start+4>:\txor    %ebp,%ebp\n```\n\n可以看出，`0x555555557fd0`是`puts@got.plt`的位置，进一步查找`GOT`表中的内存值：\n\n```asm\n(gdb) x /gx 0x555555557fd0\n0x555555557fd0 <puts@got.plt>:\t0x00007ffff7c80e50（这里我做不出来合适的结果，因为可能是程序在内存中保留，已经被一次执行后，got表被正确的填写且被保留）\n```\n\n这里是第一次，并没有被填充到`puts`函数的地址，而是一路指向了`.plt`函数，而在`.plt`函数中，进行了对应的操作，然后完成了GOT的填写。由于这里我无法继续实验，附上一个能够实现的博客：\nhttps://blog.arg.pub/2023/04/18/linux/Linux%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%AD%E7%9A%84GOT%E5%92%8CPLT/index.html\n\n>   ```asm\n>   # 这里原文是反汇编了.plt函数\n>   (gdb) x /5i $pc\n>   => 0x401020:    pushq  0x2fe2(%rip)        # 0x404008\n>      0x401026:    jmpq   *0x2fe4(%rip)        # 0x404010\n>      0x40102c:    nopl   0x0(%rax)\n>      0x401030 <printf@plt>:       jmpq   *0x2fe2(%rip)        # 0x404018 <printf@got.plt>\n>      0x401036 <printf@plt+6>:     pushq  $0x0\n>   ```\n>\n>   先看一下 GOT 表对应的内存\n>\n>   ```asm\n>   (gdb) x /4xg 0x404000\n>   0x404000:       0x0000000000403e20      0x00007fffff7df190\n>   0x404010:       0x00007fffff7c8bb0      0x0000000000401036\n>   ```\n>\n>   同上面分析 RIP 偏移法，将 0x404008h 地址所对应的内容放到栈中，然后跳转到 0x404010 来执行，我们看一下这一内存的值，然后跳转到了 ld-linux-x86-64.so.2 这个 so 我们调用完，就是将 printf 函数的地址，写入到 Got 表中，404018 [printf@GLIBC_2.2.5](mailto:printf@GLIBC_2.2.5)，GOT 表以 404000 开始，我们是 64 位的，也就是偏移 + 3 的地方，第 4 个数据。这里我们有些问题，为什么放到表中第 4 个数据呢？我们再观察一下前面的.plt 段，就会发现，printf 对应 push 0,memset 对应 push 1，按理论应该 printf 放到 GOT 表中第一项，memset 放到表中第 2 项，实际是因为 GOT 表中前三项已被占用了，有特别的用处。 GOT [0]: 自身模块的 dynamic 段地址，这里是 0x0000000000403e20， GOT [1]: 本模块的 link_map 地址，这里是 0x00007fffff7df190 GOT [2]: 系统模块中的_dl_runtime_resolve 函数地址，这里是 0x00007fffff7c8bb0 所以 printf 函数地址放到 GOT [3], 从第 4 项开始，是正常的，这里第一次是 0x0000000000401036。\n>\n>   从这里我们明白了，jmpq *0x2fe4 (% rip) 就是跳到了 GOT [2] 中_dl_runtime_resolve 的函数里面了，这个函数在 linux 的库中，算也挺复杂的，这里调用完这个函数，会将 printf 的地址写到 GOT [3] 中，并跳转到 printf 函数执行。\n>\n>   ```asm\n>   //调用形式为：\n>   _dl_runtime_resolve((link_map*)(got[1]),0);\n>   // 第一个参数为.plt开头处刚刚0x401026:    jmpq   *0x2fe4(%rip)        # 0x404010\n>   // 地址为got[1]的值，也就是0x00007fffff7df190\n>   \n>   // 第二个参数0，为<printf@plt>:中push 0；\n>   // 0x401036 <printf@plt+6>:     pushq  $0x0\n>   // 同理如果是memset,就是<memset@plt>:中push 1；\n>   // 0x401046 <memset@plt+6>:    pushq  $0x1\n>   ```\n>\n>   我们看一下内存，注意 GOT [3] 已经被写成了 0x00007fffff614e10，为 printf 的函数内存地址\n>\n>   ```asm\n>   (gdb) x /4xg 0x404000\n>   0x404000:       0x0000000000403e20      0x00007fffff7df190\n>   0x404010:       0x00007fffff7c8bb0      0x00007fffff614e10\n>   ```\n>\n>   为了这个，我们可以设置条件断点来监视一下，从此当我们下次调用 printf 函数，就不再走这一大圈的流程，直接就会调到 GOT [3] 中真正的 printf 地址。\n>\n>   GOT 表数据第一次填充： 进程从二进制装载时，GOT 表函数第一次是被 ld-linux-x86-64.so.2 填充为.plt 表中地址，然后直到调用真正函数，才像上面分析的那样，填充为真正的函数地址。\n\n我只能通过`bless`工具直接查看：\n![image-20250112181730737](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250112181730737.png)\n\n![image-20250112181739291](http://marina-too.oss-cn-hangzhou.aliyuncs.com/img/image-20250112181739291.png)\n\n根据加载进入的偏移量，直接查询`GOT`：（偏移量为`0x555555554000`）\n\n```asm\n(gdb) x /10gx 0x555555557FB8\n0x555555557fb8:\t0x0000000000003dc8\t0x0000000000000000\n0x555555557fc8:\t0x0000000000000000\t0x00007ffff7c80e50（这个就是puts函数的位置）\n0x555555557fd8:\t0x00007ffff7c29dc0\t0x0000000000000000\n0x555555557fe8:\t0x0000000000000000\t0x0000000000000000\n0x555555557ff8:\t0x00007ffff7c459a0\t0x0000000000000000\n```\n\n~~可以看到，其实原始的`GOT`中`GOT[0], GOT[1], GOT[2]`的值与执行开始的时候是不一样的，**推测是Linux加载的过程中修改的**。~~\n\n这个是错误想法，恰恰相反，是因为我没有开启延迟加载才导致出现了这种情况。\n\n## 3.4. 总结\n\nplt 和 got 配合的延迟绑定加载，可以降低程序的启动时间，只有外部函数被调用了才真正动态加载，只需要加载一次，后续再调用，无需重复，但略为增加了开销，最致命的是，GOT 表是可写的，**可以被外挂利用起来，达到替换函数攻击**。==而这个就是我目前存在的想法，通过在执行`loader.rs`加载可执行文件进入内存的时候，将`GOT`表进行重写，然后执行自己的函数==\n\n==问题==：我们需要了解`_dl_runtime_resolve`做了什么，并且尝试在ArceOS中替换这个函数，实现对`GOT`的填写。同时还要注意，`ld-linux-x86-64.so.2`是一个及其重要的东西。\n\n==截止目前，我能想到的思路就是，可以在加载的时候直接修改`GOT`，替换上述函数，或者是直接修改PLT函数，用自定义的PLT函数指定修改OPT==\n\n附录：整个`plt.c`编译出的汇编如下：\n\n```asm\nplt：     文件格式 elf64-x86-64\n\n\nDisassembly of section .init:\n\n0000000000001000 <_init>:\n    1000:\tf3 0f 1e fa          \tendbr64 \n    1004:\t48 83 ec 08          \tsub    $0x8,%rsp\n    1008:\t48 8b 05 d9 2f 00 00 \tmov    0x2fd9(%rip),%rax        # 3fe8 <__gmon_start__@Base>\n    100f:\t48 85 c0             \ttest   %rax,%rax\n    1012:\t74 02                \tje     1016 <_init+0x16>\n    1014:\tff d0                \tcall   *%rax\n    1016:\t48 83 c4 08          \tadd    $0x8,%rsp\n    101a:\tc3                   \tret    \n\nDisassembly of section .plt:\n\n0000000000001020 <.plt>:\n    1020:\tff 35 9a 2f 00 00    \tpush   0x2f9a(%rip)        # 3fc0 <_GLOBAL_OFFSET_TABLE_+0x8>\n    1026:\tf2 ff 25 9b 2f 00 00 \tbnd jmp *0x2f9b(%rip)        # 3fc8 <_GLOBAL_OFFSET_TABLE_+0x10>\n    102d:\t0f 1f 00             \tnopl   (%rax)\n    1030:\tf3 0f 1e fa          \tendbr64 \n    1034:\t68 00 00 00 00       \tpush   $0x0\n    1039:\tf2 e9 e1 ff ff ff    \tbnd jmp 1020 <_init+0x20>\n    103f:\t90                   \tnop\n\nDisassembly of section .plt.got:\n\n0000000000001040 <__cxa_finalize@plt>:\n    1040:\tf3 0f 1e fa          \tendbr64 \n    1044:\tf2 ff 25 ad 2f 00 00 \tbnd jmp *0x2fad(%rip)        # 3ff8 <__cxa_finalize@GLIBC_2.2.5>\n    104b:\t0f 1f 44 00 00       \tnopl   0x0(%rax,%rax,1)\n\nDisassembly of section .plt.sec:\n\n0000000000001050 <puts@plt>:\n    1050:\tf3 0f 1e fa          \tendbr64 \n    1054:\tf2 ff 25 75 2f 00 00 \tbnd jmp *0x2f75(%rip)        # 3fd0 <puts@GLIBC_2.2.5>\n    105b:\t0f 1f 44 00 00       \tnopl   0x0(%rax,%rax,1)\n\nDisassembly of section .text:\n\n0000000000001060 <_start>:\n    1060:\tf3 0f 1e fa          \tendbr64 \n    1064:\t31 ed                \txor    %ebp,%ebp\n    1066:\t49 89 d1             \tmov    %rdx,%r9\n    1069:\t5e                   \tpop    %rsi\n    106a:\t48 89 e2             \tmov    %rsp,%rdx\n    106d:\t48 83 e4 f0          \tand    $0xfffffffffffffff0,%rsp\n    1071:\t50                   \tpush   %rax\n    1072:\t54                   \tpush   %rsp\n    1073:\t45 31 c0             \txor    %r8d,%r8d\n    1076:\t31 c9                \txor    %ecx,%ecx\n    1078:\t48 8d 3d e4 00 00 00 \tlea    0xe4(%rip),%rdi        # 1163 <main>\n    107f:\tff 15 53 2f 00 00    \tcall   *0x2f53(%rip)        # 3fd8 <__libc_start_main@GLIBC_2.34>\n    1085:\tf4                   \thlt    \n    1086:\t66 2e 0f 1f 84 00 00 \tcs nopw 0x0(%rax,%rax,1)\n    108d:\t00 00 00 \n\n0000000000001090 <deregister_tm_clones>:\n    1090:\t48 8d 3d 79 2f 00 00 \tlea    0x2f79(%rip),%rdi        # 4010 <__TMC_END__>\n    1097:\t48 8d 05 72 2f 00 00 \tlea    0x2f72(%rip),%rax        # 4010 <__TMC_END__>\n    109e:\t48 39 f8             \tcmp    %rdi,%rax\n    10a1:\t74 15                \tje     10b8 <deregister_tm_clones+0x28>\n    10a3:\t48 8b 05 36 2f 00 00 \tmov    0x2f36(%rip),%rax        # 3fe0 <_ITM_deregisterTMCloneTable@Base>\n    10aa:\t48 85 c0             \ttest   %rax,%rax\n    10ad:\t74 09                \tje     10b8 <deregister_tm_clones+0x28>\n    10af:\tff e0                \tjmp    *%rax\n    10b1:\t0f 1f 80 00 00 00 00 \tnopl   0x0(%rax)\n    10b8:\tc3                   \tret    \n    10b9:\t0f 1f 80 00 00 00 00 \tnopl   0x0(%rax)\n\n00000000000010c0 <register_tm_clones>:\n    10c0:\t48 8d 3d 49 2f 00 00 \tlea    0x2f49(%rip),%rdi        # 4010 <__TMC_END__>\n    10c7:\t48 8d 35 42 2f 00 00 \tlea    0x2f42(%rip),%rsi        # 4010 <__TMC_END__>\n    10ce:\t48 29 fe             \tsub    %rdi,%rsi\n    10d1:\t48 89 f0             \tmov    %rsi,%rax\n    10d4:\t48 c1 ee 3f          \tshr    $0x3f,%rsi\n    10d8:\t48 c1 f8 03          \tsar    $0x3,%rax\n    10dc:\t48 01 c6             \tadd    %rax,%rsi\n    10df:\t48 d1 fe             \tsar    %rsi\n    10e2:\t74 14                \tje     10f8 <register_tm_clones+0x38>\n    10e4:\t48 8b 05 05 2f 00 00 \tmov    0x2f05(%rip),%rax        # 3ff0 <_ITM_registerTMCloneTable@Base>\n    10eb:\t48 85 c0             \ttest   %rax,%rax\n    10ee:\t74 08                \tje     10f8 <register_tm_clones+0x38>\n    10f0:\tff e0                \tjmp    *%rax\n    10f2:\t66 0f 1f 44 00 00    \tnopw   0x0(%rax,%rax,1)\n    10f8:\tc3                   \tret    \n    10f9:\t0f 1f 80 00 00 00 00 \tnopl   0x0(%rax)\n\n0000000000001100 <__do_global_dtors_aux>:\n    1100:\tf3 0f 1e fa          \tendbr64 \n    1104:\t80 3d 05 2f 00 00 00 \tcmpb   $0x0,0x2f05(%rip)        # 4010 <__TMC_END__>\n    110b:\t75 2b                \tjne    1138 <__do_global_dtors_aux+0x38>\n    110d:\t55                   \tpush   %rbp\n    110e:\t48 83 3d e2 2e 00 00 \tcmpq   $0x0,0x2ee2(%rip)        # 3ff8 <__cxa_finalize@GLIBC_2.2.5>\n    1115:\t00 \n    1116:\t48 89 e5             \tmov    %rsp,%rbp\n    1119:\t74 0c                \tje     1127 <__do_global_dtors_aux+0x27>\n    111b:\t48 8b 3d e6 2e 00 00 \tmov    0x2ee6(%rip),%rdi        # 4008 <__dso_handle>\n    1122:\te8 19 ff ff ff       \tcall   1040 <__cxa_finalize@plt>\n    1127:\te8 64 ff ff ff       \tcall   1090 <deregister_tm_clones>\n    112c:\tc6 05 dd 2e 00 00 01 \tmovb   $0x1,0x2edd(%rip)        # 4010 <__TMC_END__>\n    1133:\t5d                   \tpop    %rbp\n    1134:\tc3                   \tret    \n    1135:\t0f 1f 00             \tnopl   (%rax)\n    1138:\tc3                   \tret    \n    1139:\t0f 1f 80 00 00 00 00 \tnopl   0x0(%rax)\n\n0000000000001140 <frame_dummy>:\n    1140:\tf3 0f 1e fa          \tendbr64 \n    1144:\te9 77 ff ff ff       \tjmp    10c0 <register_tm_clones>\n\n0000000000001149 <print_banner>:\n#include <stdio.h>\n\nvoid print_banner() { printf(\"...\\n\"); }\n    1149:\tf3 0f 1e fa          \tendbr64 \n    114d:\t55                   \tpush   %rbp\n    114e:\t48 89 e5             \tmov    %rsp,%rbp\n    1151:\t48 8d 05 ac 0e 00 00 \tlea    0xeac(%rip),%rax        # 2004 <_IO_stdin_used+0x4>\n    1158:\t48 89 c7             \tmov    %rax,%rdi\n    115b:\te8 f0 fe ff ff       \tcall   1050 <puts@plt>\n    1160:\t90                   \tnop\n    1161:\t5d                   \tpop    %rbp\n    1162:\tc3                   \tret    \n\n0000000000001163 <main>:\n\nint main(void) {\n    1163:\tf3 0f 1e fa          \tendbr64 \n    1167:\t55                   \tpush   %rbp\n    1168:\t48 89 e5             \tmov    %rsp,%rbp\n  printf(\"begin\\n\");\n    116b:\t48 8d 05 96 0e 00 00 \tlea    0xe96(%rip),%rax        # 2008 <_IO_stdin_used+0x8>\n    1172:\t48 89 c7             \tmov    %rax,%rdi\n    1175:\te8 d6 fe ff ff       \tcall   1050 <puts@plt>\n  print_banner();\n    117a:\tb8 00 00 00 00       \tmov    $0x0,%eax\n    117f:\te8 c5 ff ff ff       \tcall   1149 <print_banner>\n  return 0;\n    1184:\tb8 00 00 00 00       \tmov    $0x0,%eax\n}\n    1189:\t5d                   \tpop    %rbp\n    118a:\tc3                   \tret    \n\nDisassembly of section .fini:\n\n000000000000118c <_fini>:\n    118c:\tf3 0f 1e fa          \tendbr64 \n    1190:\t48 83 ec 08          \tsub    $0x8,%rsp\n    1194:\t48 83 c4 08          \tadd    $0x8,%rsp\n    1198:\tc3                   \tret\n```\n\n# 4. ELF文件格式\n\n## 4.1. ELF中的各个节区\n\nELF节区信息概述\n\n|  节区名   | 节区说明                                                     | 备注                                                         |\n| :-------: | ------------------------------------------------------------ | :----------------------------------------------------------- |\n| .rodata1  | 和rodata类似，只存放只读数据                                 |                                                              |\n| .comment  | 存放编译器版本信息，如字符串 \"GCC:(GNU)4.2.0\"                |                                                              |\n|  .debug   | 存放调试信息                                                 |                                                              |\n| .shstrtab | 节区头部表名字的字符串表(Section Header String Table)        |                                                              |\n|   .plt    | 过程链接表(Procedure Linkage Table),用来保存长跳转格式的函数调用 |                                                              |\n|   .got    | 全局偏移表(Global Offset Table)，在地址无关代码中才需要，所有只读段需要修复的位置都间接引用到此表, 因此只读段自身就无需修复，只需修复此got表即可.<br/>.got表是在编译期间确定，静态链接期间生成的<br/>而.plt表是在静态链接期间确定，静态链接期间生成的 | 可执行文件通常不论如何编译都有got表，这是因为是否加入got表是由编译(cc1)期间决定的，而可执行文件默认连接的多个目标文件默认都有got表元素. |\n| .got.plt  | 实际上其本质是从.got表中拆除来的一部分，当开启延迟绑定(Lazy Binding)时，会将plt表中的长跳转(函数)的重定位信息单独放到此表中，以满足后续实际的延迟绑定. |                                                              |\n|  .symtab  | (静态链接)符号表的作用是保存当前 目标文件中所有对符号的定义和引用.<br/>* 符号表中UND的符号不是当前目标文件定义的，也就是对符号的引用<br/>* 符号表中其他非UND的符号，全部是定义在当前目标文件中的，也就是对符号的定义 | 默认所有非.L开头的符号都要输出，.L开头的不输出               |\n|  .strtab  | 静态链接字符串表，其中记录的是静态链接符号表中使用到的字符串，这些字符串仅供静态链接符号表使用，strip的时候会将.symtab和.strtab两个段完全清除. | 符号表的第一个元素必须是 **STN_UNDEF，**其代表一个未定义的符号索引，此符号表项内部所有值都为0 |\n|  .group   | 是用来记录多个节区的相关信息的，比如说代码段引用了数据段，这种信息是为了保证二进制处理时候不会操作错误的，像是elf自动生成的，细节见链接 |                                                              |\n\n动态链接相关节区：\n\n|  节区名   | 节区说明                                                     | 备注                                                         |\n| :-------: | :----------------------------------------------------------- | :----------------------------------------------------------- |\n|  .interp  | .interp整个段的内容就是一个字符串，此字符串为系统中动态链接器的路径，如：<br/>/lib/ld-linux-aarch64.so.1<br />linux的可执行文件加载时会去寻找可执行文件所需的动态链接器 |                                                              |\n| .dynamic  | .interp保存的是动态链接器路径，.dynamic中保存的是动态链接器用到的基本信息,如动态链接符号表(.dynsym)，字符串表(.dynstr),重定位表(.rela.dyn/rela.plt),依赖的运行时库，库查找路径等 |                                                              |\n| .rela.dyn | 记录所有变量的动态链接重定位信息（.rela.plt记录的是函数），与.rela.plt一起，是系统中唯二的两张动态链接重定位表。<br/>.rela.dyn记录除了.plt段之外所有段的动态链接重定位信息，若开启了地址无关代码，那么这些信息都应该只与.got段的地址有关. |                                                              |\n| .rela.plt | 过程连接表的动态链接重定位表，只要有过程链表，通常就会有此表，因为plt导致了绝对跳转，那么所有plt表中所有需要动态链接/重定位的绝对地址(可能在.got.plt或.got中，依赖于是否开启延迟绑定),都需要通过.rela.plt记录  <br/>  此表中记录所有全局函数(长跳转函数)的动态链接重定位信息，与.rela.dyn一起，是系统中唯二的两张动态链接重定位表。<br/>.rela.plt实际上记录的是.plt段的动态链接重定位信息，若未开启lazy binding,则这这些信息应该都只与.got段的地址有关；若开启lazy binding,则这些信息应该都只与.got.plt段的地址有关; | 需要动态链接重定位的原因主要是模块有导入符号的存在,这些符号在运行时才能确定, 地址无关代码并不能改变未定符号的本质(即不影响模块是否需要动态链接重定位), 但地址无关代码可以让重定位变得简单(如仅重定位 .got/ .data/ .got.plt) |\n|  .dynsym  | 动态链接符号表，其格式和.symtab一样，readelf -s会尝试同时输出.dynsym和.symtab，如右图.<br/>  动态链接符号表是静态链接符号表的子集，其只保留了与动态链接相关的符号信息，所有模块内部符号则不保留(因此静态符号表是可以被strip的，其只对于目标文件有用).<br/>  动态链接符号表中未定义的符号(符号引用),又称为导入符号(类似导入表)<br/>  动态链接符号表中已定义的符号(符号定义),又称为导出符号(类似导出表) | 全局符号默认是直接导出到动态链接重定位表的                   |\n|  .dynstr  | 动态链接符号表用到的字符串表，其与静态链接字符串表(.strtab)分开的原因应该是.strtab是可以完全strip的 |                                                              |\n\n参考文章：\nhttps://blog.csdn.net/weixin_46645965/article/details/136506249\n\nhttps://blog.csdn.net/xuehuafeiwu123/article/details/72963229\n\nhttps://blog.csdn.net/qq_36488756/article/details/129462449\n\nhttps://blog.csdn.net/passenger12234/article/details/123429547\n\nhttps://blog.csdn.net/lidan113lidan/article/details/119901186\n\n## 4.2. ELF的结构体\n\n### 4.2.1. ELF header\n\n64位和32位ELF文件头结构包含了同名的成员域，只是某些成员域的长度不同\n\n```c\n#define EI_NIDENT 16\n \ntypedef struct {\n    unsigned char e_ident[EI_NIDENT];\n    uint16_t      e_type;\n    uint16_t      e_machine;\n    uint32_t      e_version;\n    ElfN_Addr     e_entry;\n    ElfN_Off      e_phoff;\n    ElfN_Off      e_shoff;\n    uint32_t      e_flags;\n    uint16_t      e_ehsize;\n    uint16_t      e_phentsize;\n    uint16_t      e_phnum;\n    uint16_t      e_shentsize;\n    uint16_t      e_shnum;\n    uint16_t      e_shstrndx;\n} ElfN_Ehdr;\n```\n\n#### 4.2.1.1. 基本类型\n\n以下类型用于N位体系结构(N = 32,64，ElfN代表Elf32或*Elf64*，uintN_t代表uint32_t或uint64_t)\n\n>   Elf64_Addr（作用为Unsigned program address，表示程序内的地址，无符号）为8字节长，ELF32_Addr为4字节，等同于64或32位平台的指针类型。\n>   Elf64_Off（作用为Unsigned file offset，表示文件偏移量，无符号）为8字节长（等同于64位平台的long），Elf32_Off为4字节（等同于32位平台的int）。\n>   Elf64_Half（作用为Unsigned medium integer，表示中等大小的整数，无符号）和Elf32_Half都是2字节，  uint16_t。\n>   Elf64_Word（作用为Unsigned integer，无符号整型）和Elf32_Word都是4字节，等同于int32_t。\n\n#### 4.2.1.2. e_ident\n\n>   e_ident[0-3]：前4个元素构成魔幻数（Magic Number），取值分别为'0x7f'、'E'、'L'、'F'。\n>   e_ident[EL_CLASS=4]：ELF文件是32位的（取值为1）还是64位的（取值为2）。\n>   e_ident[EL_DATA=5]：数据的字节序是小端（Little Endian，取值为1）还是大端（Big Endian，取值为2）。\n>   e_ident[EL_VERSION=6]：ELF文件版本，正常情况下该元素取值为1。\n>   e_ident其余元素为字节对齐用。\n\n#### 4.2.1.3. e_type\n\n该成员域的长度为2个字节（类型为Elf64_Half），指明ELF文件的类型。\n\n#### 4.2.1.4. e_machine\n\n该成员域长度也为2个字节，指明该ELF文件对应哪种CPU架构。\n\n#### 4.2.1.5. e_flags\n\n和处理器相关的标识。其取值和解释依赖e_machine\n\n以ARM平台为例，介绍它的取值情况。\n\n*   在ARM32位平台（e_machine被定义为标记符EM_ARM，值为40）上，e_flags取值为0x02（标记符为EF_ARM_HASENTY），表示该ELF文件包含有效e_entry值。为什么头结构中已经定义了e_entry，而ARM平台上还需要这个参数呢？原来，在ARM平台上，e_entry取值可以为0。而这和ELF规范中ELF文件头结构的e_entry为0表示没有e_entry的含义相冲突。所以在ARM平台上，e_entry为0的真正含义就由e_flags来决定。\n*   在ARM64位平台（e_machine取值为183，标记符为EM_AARCH64）上，e_flags就没有特殊的取值\n\n#### 4.2.1.6. e_version\n\n该成员取值同e_ident[EL_VERSION]。\n\n#### 4.2.1.7. e_entry\n\n如果ELF文件是一个可执行程序的话，操作系统加载它后将跳转到e_entry的位置去执行该程序的代码。e_entry是虚拟内存地址，不是实际内存地址\n\n#### 4.2.1.8. e_phoff\n\nph是program header的缩写。由图4-1可知，program header table是执行视图中必须要包含的信息。e_phoff指明ph table在该ELF文件的起始位置（从文件头开始算起的偏移量）。\n\n#### 4.2.1.9. e_shoff\n\nsh是section header的缩写。同e_phoff类似，如果该ELF文件包含sh table的话，该成员域指明sh table在文件的起始位置。\n\n#### 4.2.1.10. e_ehsize\n\neh是elf header的缩写。该成员域表示ELF文件头结构的长度，64位ELF文件头结构长度为64。\n\n#### 4.2.1.11. e_phentsize和e_phnum\n\n这两个成员域指明ph table中每个元素的长度和该table中包含多少个元素。注意，ph表元素的长度是固定的，由此可计算ph table的大小是e_phentsize(ph entry size，每个元素的长度)×e_phnum（entry number，元素个数）。\n\n#### 4.2.1.12. e_shentsize和e_shum\n\n说明sh table中每个元素的长度以及sh table中包含多少个元素\n\n#### 4.2.1.13. e_shstrndx\n\n根据ELF规范，每个section都会有一个名字（用字符串表示）。这些字符串存储在一个类型为String的section里。这个section在sh table中的索引号就是e_shstrndx。\n\n### 4.2.2. Program Header Table\n\nExecution View中ELF必须包含Program Header Table，PH Table描述的是segment的信息\n\n```c\n\ntypedef struct {\n    uint32_t   p_type;     #segmentt标记符\n    uint32_t   p_flags;    #segment标记符\n    Elf64_Off  p_offset;   #该segment位于文件的起始位置\n    Elf64_Addr p_vaddr;    #该segment加载到进程虚拟内存空间时指定的内存地址。\n    Elf64_Addr p_paddr;    #该segment对应的物理地址。\n    uint64_t   p_filesz;   #该segment在文件中占据的大小，其值可以为0\n    uint64_t   p_memsz;    #segment在内存中占据的空间，其值可以为0\n    uint64_t   p_align;    #segment加载到内存后其首地址需要按p_align的要求进行对齐\n} Elf64_Phdr;\n```\n\n查看PH Table：`readelf -l a.out`\n\n### 4.2.3. Section Header Table\n\n```c\ntypedef struct {\n    Elf64_Word\t\tsh_name;\n    Elf64_Word\t\tsh_type;\n    Elf64_Xword\t\tsh_flags;\n    Elf64_Addr\t\tsh_addr;\n    Elf64_Off\t\tsh_offset;\n    Elf64_Xword\t\tsh_size;\n    Elf64_Word\t\tsh_link;\n    Elf64_Word\t\tsh_info;\n    Elf64_Xword\t\tsh_addralign;\n    Elf64_Xword\t\tsh_entsize;\n} Elf64_Shdr;\n```\n\n>sh_name：每个section都有一个名字。ELF有一个专门存储Section名字的Section（Section Header String Table Section，简写为shstrtab）。这里的sh_name指向shstrtab的某个位置，该位置存储了本Section名字的字符串。sh_type：section的类型，不同类型的Section存储不同的内容。比如.shstrtab的类型就是SHT_STRTAB，它存储字符串。\n>\n>sh_flags：Section的属性。下文将详细介绍sh_type和sh_flags。\n>\n>sh_addr：如果该Section被加载到内存的话（可执行程序或动态库），sh_addr指明应该加载到内存什么位置（进程的虚拟地址空间）。\n>\n>sh_offset：表明该Section真正的内容在文件什么位置。\n>\n>sh_size：section本身的大小。不同类型的Section分别对应不同的数据结构。\n\n查看 Section Header Table\n\n```sh\nreadelf --sections main.o\n或\nreadelf -S main.o\n```\n\n根据ELF规范，sh table表第0项是占位用的，所以其值全为0\n\n\n\n#### 4.2.3.1. .shstrtab section   \n\nSection Header String Table的简写，Section的名字是字符串，这些字符串信息存储在Section Header String Table中\n\n将指定名字或索引的section的内容转换成字符信息打印出来：`readelf -p [section名|section索引] main.o`\n\n#### 4.2.3.2. .text section\n\n用于存储程序的指令\n\n.text section的sh_type为SHT_PROGBITS（取值为1），意为Program Bits，即完全由应用程序自己决定（程序的机器指令当然是由程序自己决定的），sh_flags为SHF_ALLOC（当ELF文件加载到内存时，表示该Section会分配内存）和SHF_EXECINSTR（表示该Section包含可执行的机器指令）\n\n用 \"objdump-S-d main.o\"可反编译.text的内容。\"-S\"参数表示结合源码进行反汇编。这要求编译main.o的时候使用gcc-g参数。\n\n#### 4.2.3.3. .bss section\n\nblock storage segment的缩写\n\n.bss section包含了一块内存区域，这块区域在ELF文件被加载到进程空间时会由系统创建并设置这块内存的内容为0。注意，.bss section在ELF文件里不占据任何文件的空间，所以其sh_type为SHF_NOBITS（取值为8）\n\n.bss的sh_flags取值必须为SHF_ALLOC和SHF_WRITE（表示该区域的内存是可写的。同时，因为该区域要初始化为0，所以要求该区域内存可写）。\n\n打印指定section的内容`readelf -x section名 main.o`\n\n#### 4.2.3.4. .data section\n\n.data和.bss类似，但是它包含的数据不会初始化为0。这种情况下就需要在文件中包含对应的信息了。所以.data的sh_type为SHF_PROGBITS，但sh_flags和.bss一样。读者可以尝试在main.c中定义一个比如\"char c='f'\"这样的变量就能看到.data section的变化了。\n\n#### 4.2.3.5. .rodata section\n\n包含只读数据的信息，比如main.c中printf里的字符串就属于这一类。它的sh_flags只能为SHF_ALLOC。\n\n#### 4.2.3.6. .symtab section\n\n里边存储的是符号表（Symbol Table）。.symtab section的类型为SHT_SYMTAB。**一般而言，符号表主要用于编译链接，也可以参与动态库的加载。**\n\n```c\ntypedef struct {\n    Elf64_Word\t\tst_name;\n    unsigned char\tst_info;\n    unsigned char\tst_other;\n    Elf64_Half\t\tst_shndx;\n    Elf64_Addr\t\tst_value;\n    Elf64_Xword\t\tst_size;\n} Elf64_Sym;\n\n#define ELF64_ST_BIND(info)\t\t\t((info) >> 4)\n#define ELF64_ST_TYPE(info)\t\t\t((info) & 0xf)\n#define ELF64_ST_INFO(bind, type)\t(((bind)<<4) + ((type)&0xf))\n```\n\n>   st_name：该符号的名称，指向.strtab section某个索引位置。\n>\n>   st_info：说明该符号的类型和绑定属性（binding attributes）。\n>\n>   st_other：说明该符号的可见性（Visibility）。它往往和st_info配合使用，用法见上图所示的三个宏。\n>\n>   st_shndx：symbol table中每一项元素都和其他section有关系。st_shndx就是这个相关section的索引号\n>\n>   st_value：符号的值，不同类型的ELF文件该变量的含义不同。比如：对于relocatable类型，st_value：表示该符号位于相关section（索引号为st_shndx）的具体位置。而对于shared和executable类型，st_value为该符号的虚拟内存地址。\n>\n>   st_size：和这个符号关联的数据的长度\n\n\n\n\n\n# 5. SO文件的操作手撕姿势\n\n找到Symbol Table符号表，然后对其中的符号的入口地址进行查询\n\n# 结论\n\n在仔细研究上述流程后，我目前的设想如下：\n\n与在张同学修改`GOT`的基础上，拓展支持从`PLASH`中加载SO的模式：\n\n首先加载完整的动态链接库进入内存中。\n\n1）延迟加载的动态绑定技术。在加载可执行文件的时候，直接替换`GOT`中的`GOT[2]`表项，重定位到自己的解析函数，然后进一步对`GOT`进行操作，将内存中的动态库的对应函数入口写入GOT。\n\n2）加载时绑定。在加载可执行文件的时候，通过遍历可执行文件的`rela.dyn`表项，将对应的，在内存中存在的动态链接库的函数入口填入`GOT`表格中。\n\n思路二的优势：\n\n1）能减小ArceOS本身的大小，不需要涵盖so库。在不需要动态链接的时候可以不加载SO库，而需要的时候可以去加载。不用像是思路一一样需要重新构建ArceOS本身才能完成两个状态的切换。\n\n2）有利于快速开发，拓展库支持。只需要替换原有库的一些底层组件，就可以大概率实现正确，而不需要像思路一一样还要再搞一遍库的支持。\n\n思路二的劣势：\n\n1）需要花费额外的时间加载so库，相比思路一要慢一些。但是考虑到Unikernel的特性，我怀疑这个不是一个劣势。\n\n2）在发布ArceOS的时候，需要将修改的so库与对应的组件一同发布，比直接思路一可以直接发布一个组件要麻烦很多。\n\n","tags":["ArceOS开发日记","Linux","动态加载","ELF"]}]
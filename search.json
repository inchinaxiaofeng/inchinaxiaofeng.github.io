[{"title":"手撕SO文件","url":"/2025/01/12/手撕SO文件/","content":"\n# 0. 问题的提出与总目标\n\n在为ArceOS实现动态加载的时候，同组的一个同学贡献了这样的思路：直接在Rust中实现对应的库，然后在load的过程中，将函数直接复制到rela指出的位置。我的思路是希望通过直接加载so文件，实现对动态链接的支持。\n\n# 1. 静态链接与动态链接概念的简单区分\n\n静态链接是将所有第三方库函数全部打包到了一个可执行文件中，其体积较大，加载简单，其使用的库常用名称是`*.a`，是通过`ar`构建的；\n动态链接不链接库文件，而是在运行时去加载，体积小，实现复杂，其使用的库常用名称为`*.so`，通过`gcc`类编译器构建的。\n\n我们把编译后但是还未链接的二进制机器码文件称为目标文件（Object File），那些第三方库是其他人编译打包好的目标文件，这些库里面包含了一些函数，我们可以直接调用而不用自己动手写一遍。在编译构建自己的可执行文件时，使用静态链接的方式，其实就是将所需的静态库与目标文件打包到一起。最终的可执行文件除了有自己的程序外，还包含了这些第三方的静态库，可执行文件比较臃肿。\n\n动态链接不将所有的第三方库都打包到最终的可执行文件上，而是只记录用到了哪些动态链接库，在运行时才将那些第三方库装载（Load）进来。装载是指将磁盘上的程序和数据加载到内存上。\n\n> 注意的是，不同操作系统的动态链接库格式不同，linux的是共享目标文件（Shared Object）`.so`，windows的是动态链接库（Dynamic Link Library）`.dll`\n\n# 2. 位置无关码PIC的原理、动态链接库、代码重定位\n\n问题：动态链接库在编译时并未确定其在内存中的具体位置，而是在运行时加载，因此必须进行加载时重定位。\n\nNOTE!: 本节参考文章：<https://blog.csdn.net/tilblackout/article/details/135585340>\n\n## 1. 位置无关的编译器选项\n\n这四个编译选项与位置无关代码(Position Independent Code，PIC)和位置无关可执行文件(Position Independent Executable，PIE)有关。它们的作用主要是为了提高代码的可重定位性，使得代码更适用于共享库和在内存中的不同位置加载的情况：\n\n1. `-fPIC(Position Independent Code)`\n    * **作用：**生成位置无关代码，适用于共享库。\n    * **用途：**当编译共享库时，通常需要使用`-fPIC`，以确保库中代码可以在内存中的不同位置加载。\n2. `-fPIE(Position Independent Executable)`\n    * **作用：** 生成位置无关的可执行文件，适用于可执行文件。\n    * **用途：** 当编译可执行文件时，使用`-fPIE`会生成一个可以在内存中的不同位置加载的可执行文件。\n3. `-pie(Position Independent Executable)`\n    * **作用：** 生成位置无关的可执行文件，与`-fPIE`类似。\n    * **用途：** 在链接阶段，使用`-pie`可以生成位置无关的可执行文件，这也是为了提高安全性。与 `-fPIE` 不同的是，`-pie`在链接时指定，而不是在编译时。\n4. `-fno-pic`\n    * **作用：** 禁用位置无关代码。\n    * **用途：** 当不需要位置无关代码时，使用`-fno-pic`禁用，生成与地址相关的代码。\n\n## 2. 加载动态链接库\n\n### 2.1. 问题引入\n\n构建动态链接库的时候，链接器事先无法知道任何给定共享库将在进程的虚拟内存中的哪个位置加载。这个问题的解决方法视操作系统不同而不同，这里以Linux为例来讲解一个实现的思路。\n\n```c\nint test = 10;\n\nint func(int a)\n{\n    test += a;\n    return test;\n}\n```\n\n上述代码编译成动态链接库后，涉及到用`mov`指令将全局变量`test`的值从内存的位置取到寄存器中。但是`mov`指令需要**绝对地址**，而动态库是没有预定义的加载地址，所以这个地址将在运行时确定。\n\nLinuxELF共享库中，主要有两个解决这个问题的方法：加载时重定位和位置无关代码。\n\n### 2.2. 加载时重定位（Load-time relocation）\n\n* **实时性：** 在加载时进行地址重定位，即在将共享库加载到进程的地址空间时，需要根据实际的加载地址对库中的数据和代码引用进行修正。这就是为什么称之为“加载时”重定位。\n* **非位置无关：** 共享库中的代码和数据引用是使用绝对地址的，因此必须在加载时将这些地址调整为实际的加载地址。\n\n存在的问题：\n\n1. 性能问题\n    当一个应用程序加载与加载时重定位条目关联的共享库时，尽管只需加载重定位的条目，但如果一个复杂的软件在启动时加载多个大型共享库，并且每个库都需要进行加载时重定位，会导致应用程序启动时间明显延迟。\n2. 代码段无法共享\n    共享库的初衷之一是为了节省RAM，使得一些常见的共享库能够被多个应用程序共享。这意味着对于每个应用程序，共享库都必须完全加载到内存中，导致相当大量的RAM浪费。\n3. 要求代码段可写\n    为了允许在加载时动态地修改其中的绝对地址，将其调整为实际的加载地址，加载时重定位要求代码段保持可写状态，这带来了潜在的代码安全风险。\n\n对于加载时重定位这种方法，实际上已经过时了，甚至最新的编译器已经不支持这种方法。PIC是目前常见的解决方案，接下来我们就深入讨论一下位置无关代码。\n\n## 3. 位置无关代码（Position Independent Code）\n\nPIC的原理很简单：在代码中对所有全局数据和函数引用添加一个额外的中间层。通过巧妙地利用链接和加载过程中的结果，使共享库的代码部分实现位置无关。\n\n### 3.1.  代码段和数据段之间的偏移\n\nPIC的一个关键点是利用链接时已知的代码段和数据段之间的偏移。当链接器合并多个目标文件时，它会整合它们的各个部分，形成一个大的代码段。因此，链接器了解各个部分的大小和它们的相对位置。\n\n举例来说，代码段可能直接跟在数据部分后面，这意味着从代码部分中的任意指令到数据段开头的偏移量等于代码部分的大小减去指令距离代码部分开头的偏移量。这两个量都是链接器已知的。\n\n当然，其实在代码段和数据段之间有别的段，或者两个段的位置关系不是如此，都不影响链接器**知晓**它们的位置，并了解到所有段的大小。\n\n### 3.2. 全局偏移表（Global Offset Table）\n\n全局偏移表`GOT`可以帮我们实现位置无关数据寻址。实际上`GOT`就是一个地址表，存储在数据段中。假设代码段中的某个指令想要引用一个变量。**它会引用`GOT`中的一个条目，而不是直接使用绝对地址引用(这将需要进行重定位)。**由于`GOT`位于数据段的一个已知位置，这个引用是**相对的**，并且在链接器中是**已知的**，而`GOT`条目本身将包含变量的**绝对地址**。\n\n通过将变量引用重定向到GOT，我们避免了在代码段中直接使用绝对地址，而是通过GOT中的条目进行引用，从而减少了需要在加载时进行的具体地址修正。但是，我们在数据段中引入了一个新的重定位，因为全局偏移表仍然需要包含变量的绝对地址。那么，这样做的优点有哪些呢？\n\n* 加载时重定位需要对每个变量的引用都进行重定位，而在全局偏移表中，只需要对每个变量进行一次重定位\n* 数据段是可写的，并且在进程之间不共享\n\n实际上这就是解决前面提到的加载时重定位的三个缺点。\n\n ==这里我们需要重点关注的是==：**Linux的动态链接器如何在运行时对全局偏移表进行修改**。我们将通过了解这个内容，获得在ArceOS中直接加载SO文件的必要知识。\n\n### 3.3. 函数的重定位\n\n前面介绍的是全局变量的重定位，对于函数也需要重定位，它有着另一种机制：懒绑定。\n\n当共享库引用某个函数时，函数的真实地址在加载时未知。为了加速这个过程，引入了过程链接表(PLT)。PLT包含对函数进行间接调用的代码，而不是直接包含函数地址。在程序执行时，当函数首次调用时，PLT代码负责将函数的真实地址填充到全局偏移表(GOT)中的相应条目。此后的调用直接通过GOT访问函数地址，避免了每个函数调用时的绑定延迟。这种机制减少了不必要的解析工作，提高了程序执行效率。\n\n==这里我们可以知道==：存在某种方式，能够让我们在ArceOS中进行函数重定位。\n\n## 4. 总结\n\n至此解释了什么是位置无关代码，以及它如何帮助创建具有可共享只读文本段的共享库。位置无关代码(PIC)通过引入全局偏移表(GOT)和过程链接表(PLT)实现，解决了共享库加载时的重定位问题。GOT提供了数据和函数的间接引用，PLT实现了懒绑定，推迟函数地址的解析。当然这也伴随额外的内存加载和寄存器使用成本，但在权衡之下，现代的编译器都更倾向于使用PIC。\n","tags":["ArceOS开发日记","Linux","动态加载"]},{"title":"通过优化合成层优化性能","url":"/2021/09/04/通过压缩合成层优化性能/","content":"\n## 背景\n\nWeb 性能优化特别是长列表滚动优化是一个老生常谈的问题，一般我们的思路是通过虚拟滚动、GPU 加速、fragment 复用等方式优化性能。\n\n在本篇文章中，主要介绍一个压缩合成层的思路来进行性能优化，关于合成层的文章网上也有一些（附录部分有列出），不过大部分文章会对合成层创建的原因进行冗长的介绍，本文会跳过这些部分。原因是我们通过 devTools 可以比较方便的针对具体情况分析创建合成层的原因，另外一个原因是 blink 已经把创建合成层的原因写到了一个文件中（[传送门](https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/platform/graphics/compositing_reasons.cc)），我们直接参考就行，也没有必要去全都记住。\n\n\n## 合成层是什么\n\n对于 blink 渲染引擎的渲染流程，大致可以分为以下几个阶段：\n\n```\nDom Tree -> Layout Object -> Paint Layer -> Graphics Layers Tree -> Paint\n```\n\n我们对以上过程进行一个简述：\n\n* Dom Tree 到 Render Tree 这个过程，基本是一一对应的，除了一些 display:none 的元素。\n* Layout Object 会按照一定条件创建 Paint Layer。\n* Paint Layer 在到 Graphics Layer 的过程中，会创建合成层（Composite Layer），会对应独立的 Graphics Layer。\n* Graphics Layer 会把结果渲染到纹理，最终通过 Chrome 的渲染层以及系统进行上屏。\n\n实际上我们可以发现，合成层的多少会比较影响我们的渲染性能，合成层比较多的情况下，当我们对页面进行交互（比如滚动），触发重新渲染，就会有卡顿的风险。\n\n## 分析合成层\n\nChrome 的 DevTools 工具可以让我们比较方便地进行合成层分析，例如我们通过一个 demo 来进行分析：\n\n![合成层示例](/img/composite_reason.png)\n\n在上图中，我们会发现这个 demo 的合成层比较多，我们点进去可以查看到是因为 overflow 导致创建了新的合成层。\n\n也就是说，对该 demo 而言我们可以尝试在这些 Demo 中去掉或者修改 overflow 的相关设置，从而进行合成层优化。\n\n## 优化合成层\n\n我们尝试去掉 `overflow: scroll;`。（ Demo 源代码会在本文最后给出）\n\n然后我们设置页面的列表元素为 500 个，通过模拟页面持续滚动，来检查去掉前后的性能。\n\n去掉前，cpu 保持在 50%+，这实际上已经是一个比较高的数值了：\n\n![合成层cpu](/img/composite_cpu_1.png)\n\n去掉后，cpu 保持在 2% 左右：\n\n![去除合成层cpu](/img/composite_cpu_2.png)\n\n我们可以看到，优化后有巨大的性能提升，这种量级的性能提升，会远超虚拟滚动等方案（其实我个人是不建议采用虚拟滚动的，非常难维护，而且你很难做到浏览器原生滚动的丝滑水准）。\n\n## 附录\n\n示例代码：\n\n```\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0,minimal-ui:ios\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n  <style >\n    .container {\n      width: 100vw;\n      height: 100vh;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n    }\n    .list {\n      width: 500px;\n      height: 90vh;\n      overflow: scroll;\n    }\n    .li {\n      width: 100%;\n      height: 50px;\n      border-bottom: 2px;\n      border-style: solid;\n      border-color: grey;\n      /* overflow: scroll; */\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"list\">\n    </div>\n  </div>\n</body>\n<script>\n  const totalListCount = 500;\n  const list = document.querySelector(\".list\");\n\n  for(let i = 0; i < totalListCount; i += 1) {\n    let fragment = document.createElement(\"div\");\n    fragment.classList.add(\"li\");\n    fragment.innerHTML = `<p>this is the ${i} element</p>`;\n    list.appendChild(fragment);\n  }\n  let curr = 0;\n  const renderScroll = function () {\n    curr += 5;\n    if (curr >= totalListCount) curr = 0;\n    list.children[curr].scrollIntoView();\n    window.requestAnimationFrame(renderScroll)\n  };\n  renderScroll();\n</script>\n</html>\n```\n\n参考：\n\n- Compositing Layers: https://zhuanlan.zhihu.com/p/88288584\n- 前端性能优化之 Composite: https://segmentfault.com/a/1190000015917498","tags":["性能优化"]}]